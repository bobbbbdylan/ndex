!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.Ndex=n():e.Ndex=n()}(this,function(){return function(e){function n(r){if(t[r])return t[r].exports;var o=t[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var t={};return n.m=e,n.c=t,n.p="",n(0)}([function(e,n,t){var r,o,a,i;o=t(1),r=t(2),i=t(4),a=function(){function e(){this.connections={}}return e.prototype.connect=function(e,n,t){return null==t&&(t=null),new Promise(function(a){return function(s,u){var c;if(!t){if(c=a.connections[e])return u(new Error("Already connected to “"+e+"”"));c=new o(e,n),t=a.connections[e]=a.getAdapter(c)}return t.handleMethod("open").then(function(e){return t.proxyObjectStoresNamespace(e),s(t)}).catch(function(n){return t instanceof i?(t=a.connections[e]=new r(c),console.info("Ndex: Fallbacking to BrowserAdapter for “"+e+"” because “"+n+"”"),s(a.connect(null,null,t))):u("Ndex: "+n)})}}(this))},e.prototype.getAdapter=function(e){var n;return new(n=this.getAdapterClass())(e)},e.prototype.getAdapterClass=function(){return this.workersAreSupported()?i:r},e.prototype.workersAreSupported=function(e){return null==e&&(e=window),null!=this._workersAreSupported?this._workersAreSupported:this._workersAreSupported="Worker"in e},e}(),e.exports=new a},function(module,exports,__webpack_require__){var factory,slice=[].slice;factory=function(){var Connection;return Connection={},Connection.API=function(){function API(e,n){this.name=e,this.migrations=n,this.database=null,this.queue={},this.logging=new Connection.Logging}return API.prototype.parseMigrations=function(e){var n;return n=Object.keys(e).sort(),n.map(function(n){return function(n){var t,r,o;return o=parseInt(n),r=n.match(/_(.+)/),t=r?r[1].replace(/(\w)([A-Z])/g,function(e,n,t){return n+" "+t.toLowerCase()}):"",{version:o,title:t,migration:e[n],key:n}}}(this))},API.prototype.deleteDatabase=function(){return new Promise(function(e){return function(n){var t;return e.database?(e.close(),t=indexedDB.deleteDatabase(e.database.name),t.onsuccess=function(e){return setTimeout(function(){return n()},0)}):n()}}(this))},API.prototype.open=function(){return this.dbPromise?this.dbPromise:this.dbPromise=new Promise(function(_this){return function(resolve,reject){var e,migrations,request;if(!self.indexedDB)return reject("indexedDB isn’t supported");migrations=_this.parseMigrations(_this.migrations);try{request=indexedDB.open(_this.name,migrations.length+1)}catch(n){return e=n,reject(e.message||e.name)}return request.onupgradeneeded=function(e){var db,j,len,migration,migrationTransaction,results,transaction;for(db=e.target.result,transaction=e.target.transaction,migrationTransaction=new Connection.Migration(db,transaction),migrationTransaction.createObjectStore("migrations",{keyPath:"version"}),results=[],j=0,len=migrations.length;j<len;j++)migration=migrations[j],"string"==typeof migration.migration&&(migration.migration=eval("__"+migration.key+" = "+migration.migration)),(migration.migration.up||migration.migration).bind(migrationTransaction).call(),delete migration.migration,results.push(transaction.objectStore("migrations").put(migration));return results},request.onsuccess=function(e){var n,t;return n=e.target.result,t=[].slice.call(n.objectStoreNames),_this.createNamespaceForObjectStores(t),n.onversionchange=function(){return _this.close()},_this.database=n,resolve(t)},request.onerror=function(e){return reject(request.error.message||request.error.name)}}}(this))},API.prototype.close=function(){return new Promise(function(e){return function(n){return e.dbPromise&&delete e.dbPromise,e.database&&e.database.close(),n()}}(this))},API.prototype.get=function(e,n,t){return new Promise(function(r){return function(o){var a;return Array.isArray(n)?(a=Promise.all(n.map(function(n){return r.get(e,n)})),a.then(o)):r.enqueue("read",e,function(a){var i;return r.logging.addRequest(a,"get",e,t,{key:n}),i=r.createRequest(a,e,t),i.get(n).onsuccess=function(e){var n;return n=e.target.result,void 0===n&&(n=null),o(n)}})}}(this))},API.prototype.getFirst=function(e,n){return new Promise(function(t){return function(r){return t.enqueue("read",e,function(o){var a;return t.logging.addRequest(o,"getFirst",e,n),a=t.createRequest(o,e,n),a.openCursor().onsuccess=function(e){var n,t;return(n=e.target.result)?(t=n.value,a.keyPath||(t._key=n.key),r(t)):r(null)}})}}(this))},API.prototype.getAll=function(e,n){return new Promise(function(t){return function(r){return t.enqueue("read",e,function(o){var a,i;return t.logging.addRequest(o,"getAll",e,n),i=[],a=t.createRequest(o,e,n),a.openCursor().onsuccess=function(e){var n,t;return(n=e.target.result)?(t=n.value,a.keyPath||(t._key=n.key),i.push(t),n.continue()):r(i)}})}}(this))},API.prototype.add=function(e,n,t){var r;return void 0===t&&(r=[null,n],n=r[0],t=r[1]),new Promise(function(r){return function(o){var a;return!n&&Array.isArray(t)?(a=Promise.all(t.map(function(n){return r.add(e,n)})),a.then(o)):n&&Array.isArray(n)&&Array.isArray(t)?(a=Promise.all(n.map(function(n,o){return r.add(e,n,t[o])})),a.then(o)):r.enqueue("write",e,function(a){var i,s;return r.logging.addRequest(a,"add",e,null,{key:n,data:t}),i=n?[t,n]:[t],s=r.createRequest(a,e),s.put.apply(s,i).onsuccess=function(e){return t._key=e.target.result,o(t)}})}}(this))},API.prototype.update=function(e,n,t){return new Promise(function(r){return function(o){return r.enqueue("write",e,function(a){var i;return r.logging.addRequest(a,"update",e,null,{key:n,data:t}),i=r.createRequest(a,e),i.get(n).onsuccess=function(i){var s,u,c,l,d,p;return d=i.target.source.keyPath,l=!!d,u=i.target.result,void 0===u?(u=t,l&&(u[d]=n)):(c=function(e,n){var t,r,o;r=[];for(t in e)o=e[t],"object"!=typeof o?r.push(n[t]=o):c(o,n[t]);return r})(t,u),s=l?[u]:[u,n],p=r.createRequest(a,e),p.put.apply(p,s).onsuccess=function(){return o(u)}}})}}(this))},API.prototype.increment=function(e,n,t,r){return null==t&&(t=1),new Promise(function(o){return function(a){return o.enqueue("write",e,function(i){var s;return o.logging.addRequest(i,r?"decrement":"increment",e,null,{key:n,data:t}),s=o.createRequest(i,e),s.get(n).onsuccess=function(s){var u,c,l,d,p,f;return p=s.target.source.keyPath,d=!!p,c=s.target.result,d?(l=function(e,n){var t,o,a;o=[];for(t in e)a=e[t],"object"!=typeof a?(n[t]||(n[t]=0),o.push(n[t]+=r?-a:a)):l(a,n[t]);return o})(t,c):(c||(c=0),c+=r?-t:t),u=d?[c]:[c,n],f=o.createRequest(i,e),f.put.apply(f,u).onsuccess=function(){return a(c)}}})}}(this))},API.prototype.decrement=function(e,n,t){return this.increment(e,n,t,!0)},API.prototype.delete=function(e,n){return new Promise(function(t){return function(r){var o;return Array.isArray(n)?(o=Promise.all(n.map(function(n){return t.delete(e,n)})),o.then(r)):t.enqueue("write",e,function(o){var a;return t.logging.addRequest(o,"delete",e,null,{key:n}),a=t.createRequest(o,e),a.delete(n).onsuccess=function(e){return r(n)}})}}(this))},API.prototype.deleteWhere=function(e,n,t){return n.remove=!0,this.where(e,n,t)},API.prototype.clear=function(e){return new Promise(function(n){return function(t){return n.enqueue("write",e,function(r){var o;return n.logging.addRequest(r,"clear",e),o=n.createRequest(r,e),o.clear().onsuccess=function(){return t()}})}}(this))},API.prototype.clearAll=function(){return new Promise(function(e){return function(n){var t,r;return t=slice.call(e.database.objectStoreNames),t=t.filter(function(e){return"migrations"!==e}),r=Promise.all(t.map(function(n){return e.clear(n)})),r.then(n)}}(this))},API.prototype.reset=function(e,n,t){return new Promise(function(r){return function(o){return r.clear(e).then(function(){return r.add(e,n,t).then(o)})}}(this))},API.prototype.index=function(e,n){return this.createNamespaceForIndex(n,e)},API.prototype.where=function(objectStoreName,predicates,indexName){var readWrite;return readWrite=predicates.remove?"write":"read",new Promise(function(_this){return function(resolve){return _this.enqueue(readWrite,objectStoreName,function(transaction){var bound,bounds,contains,count,eq,eqIsArray,exact,except,gt,gteq,hasValues,isEquivalent,isInclusive,isLowerBound,k,knownUniques,limit,lower,lt,lteq,offset,only,order,range,ref,remove,request,result,uniq,uniques,upper,v;_this.logging.addRequest(transaction,"where",objectStoreName,indexName,{data:predicates}),lt=predicates.lt,lteq=predicates.lteq,gt=predicates.gt,gteq=predicates.gteq,eq=predicates.eq,limit=predicates.limit,offset=predicates.offset,only=predicates.only,contains=predicates.contains,except=predicates.except,uniq=predicates.uniq,order=predicates.order,remove=predicates.remove,uniques=Array.isArray(uniq)?uniq:uniq?[uniq]:[],order="desc"===order?"prev":"next",bounds={},ref={lt:lt,lteq:lteq,gt:gt,gteq:gteq,eq:eq};for(k in ref)v=ref[k],void 0!==v&&(isInclusive="gteq"===k||"lteq"===k,isEquivalent="eq"===k,isLowerBound="gt"===k||"gteq"===k,bound=isEquivalent?"exact":isLowerBound?"lower":"upper",bounds[bound]={value:v,open:!isInclusive});return range=null,eqIsArray=!1,lower=bounds.lower,upper=bounds.upper,exact=bounds.exact,exact?(eqIsArray=Array.isArray(eq))?(eq.sort(),lower={value:eq[0],open:!1},upper={value:eq[eq.length-1],open:!1},range=IDBKeyRange.bound(lower.value,upper.value,lower.open,upper.open)):range=IDBKeyRange.only(exact.value):lower&&upper?range=IDBKeyRange.bound(lower.value,upper.value,lower.open,upper.open):lower?range=IDBKeyRange.lowerBound(lower.value,lower.open):upper&&(range=IDBKeyRange.upperBound(upper.value,upper.open)),result=[],count=0,knownUniques={},hasValues=function(e,n,t){return Array.isArray(t)||(t=[t]),t.indexOf(e[n])!==-1},request=_this.createRequest(transaction,objectStoreName,indexName),request=range?request.openCursor(range,order):request.openCursor(),request.onsuccess=function(e){var a,cursor,j,keyPath,knownValues,len,value;if(!(cursor=e.target.result))return resolve(result);value=cursor.value,eqIsArray&&(keyPath=e.target.source.keyPath,only||(only={}),only[keyPath]=eq);for(k in only)if(v=only[k],!hasValues(value,k,v))return cursor.continue();for(k in contains)if(v=contains[k],Array.isArray(v)||(v=[v]),a=value[k],Array.isArray(a)||(a=[a]),!_this.intersect(a,v).length)return cursor.continue();for(k in except)if(v=except[k],hasValues(value,k,v))return cursor.continue();for(j=0,len=uniques.length;j<len;j++){if(k=uniques[j],knownValues=knownUniques[k]||(knownUniques[k]=[]),knownValues.indexOf(value[k])!==-1)return cursor.continue();knownUniques[k].push(value[k])}if(count++,offset&&count<=offset)return cursor.continue();if(result.push(value),remove&&cursor.delete(),limit){if("string"==typeof limit&&(limit=eval("__limit = "+limit)),"function"==typeof limit&&limit(result))return resolve(result);if(limit===result.length)return resolve(result)}return cursor.continue()}})}}(this))},API.prototype.getMethodsForObjectStore=function(){return this._getMethodsForObjectStore||(this._getMethodsForObjectStore=["get","getFirst","getAll","add","update","increment","decrement","delete","deleteWhere","clear","reset","index","where"])},API.prototype.getMethodsForIndex=function(){return this._getMethodsForIndex||(this._getMethodsForIndex=["get","getFirst","getAll","where","deleteWhere"])},API.prototype.createNamespaceForObjectStores=function(e,n){var t,r,o,a;for(null==e&&(e=[]),null==n&&(n=this),a=[],t=0,r=e.length;t<r;t++)o=e[t],"migrations"!==o&&a.push(this.createNamespaceForObjectStore(o,n));return a},API.prototype.createNamespaceForObjectStore=function(e,n){var t;return null==n&&(n=this),t=n[e]={},this.getMethodsForObjectStore().forEach(function(r){return function(r){return t[r]=function(){return n[r].apply(n,[e].concat(slice.call(arguments)))}}}(this)),t},API.prototype.createNamespaceForIndex=function(e,n,t){var r;return null==t&&(t=this),r={},this.getMethodsForIndex().forEach(function(o){return function(o){return r[o]=function(){return t[o].apply(t,[n].concat(slice.call(arguments),[e]))}}}(this)),r},API.prototype.createRequest=function(e,n,t){var r;return r=e.objectStore(n),t?r.index(t):r},API.prototype.createTransaction=function(e,n,t){return this.open().then(function(r){return function(){var o;return o=r.database.transaction([n],e),t(o)}}(this)).catch(function(e){return function(e){throw e}}(this))},API.prototype.intersect=function(e,n){var t,r,o;for(t=0,r=0,o=[];t<e.length&&r<n.length;)e[t]<n[r]?t++:e[t]>n[r]?r++:(o.push(e[t]),t++,r++);return o},API.prototype.enqueue=function(e,n,t){var r,o;return(r=this.queue)[n]||(r[n]=[]),o={readwrite:e,callback:t},this.queue[n].length||this.scheduleTransaction(n),this.queue[n].push(o)},API.prototype.scheduleTransaction=function(e){return setTimeout(function(n){return function(){var t,r,o,a;return a=n.queue[e].splice(0),r=a.map(function(e){return e.readwrite}),o=r.some(function(e){return"write"===e}),t=o?"readwrite":"readonly",n.createTransaction(t,e,function(t){var r,o,i,s;for(n.logging.addTransaction(t,e),s=[],r=0,o=a.length;r<o;r++)i=a[r],s.push(i.callback(t));return s})}}(this),0)},API}(),Connection.Migration=function(){function e(e,n){this.db=e,this.transaction=n}return e.prototype.createObjectStore=function(e,n){if(!this.db.objectStoreNames.contains(e))return this.db.createObjectStore(e,n)},e.prototype.deleteObjectStore=function(e){if(this.db.objectStoreNames.contains(e))return this.db.deleteObjectStore(e)},e.prototype.createIndex=function(e,n,t,r){var o;if(o=this.transaction.objectStore(e),!o||!o.indexNames.contains(n))return o.createIndex(n,t,r)},e.prototype.deleteIndex=function(e,n){var t;if(t=this.transaction.objectStore(e),t&&t.indexNames.contains(n))return t.deleteIndex(n)},e}(),Connection.Logging=function(){function e(){this.queues=[]}return e.prototype.addTransaction=function(e,n){var t;if(this.handleLog)return this.queues.push({transaction:e,objectStoreNames:n,requests:[],start:Date.now()}),t=function(e){return function(n){return e.logTransaction(n.target)}}(this),e.onabort=t,e.onerror=t,e.oncomplete=t},e.prototype.addRequest=function(e,n,t,r,o){var a;if(this.handleLog&&(a=this.queues.filter(function(n){return n.transaction===e})[0]))return a.requests.push({method:n,objectStoreName:t,indexName:r,data:o})},e.prototype.logTransaction=function(e){var n,t,r,o,a,i,s,u,c,l,d,p,f,h,m,g;if(this.handleLog&&(d=this.queues.filter(function(n){return n.transaction===e})[0])){for(c="readwrite"===d.transaction.mode?"write":"read ",m=d.requests.length,t=Date.now(),g=t-d.start,this.handleLog({type:"transaction.start",data:"Ndex: "+c+" "+d.objectStoreNames+" "+g+"ms ("+m+" request"+(m>1?"s":"")+")"}),p=d.requests,o=0,i=p.length;o<i;o++){switch(h=p[o],u=h.method,l=h.objectStoreName,r=h.indexName,n=h.data,n&&(f=n,a=f.key,n=f.data),s=[],u){case"get":s=["GET",a,"FROM",l];break;case"getFirst":s=["GET FIRST",a,"FROM",l];break;case"getAll":s=["GET ALL","FROM",l];break;case"add":s=["ADD",JSON.stringify(n),"TO",l],a&&(s=s.concat(["WITH KEY",a]));break;case"update":s=["UPDATE",a,"FROM",l,"SET",JSON.stringify(n)];break;case"increment":"object"==typeof n&&(n=JSON.stringify(n)),s=["INCREMENT",n,"TO KEY",a,"FROM",l];break;case"decrement":"object"==typeof n&&(n=JSON.stringify(n)),s=["DECREMENT",n,"TO KEY",a,"FROM",l];break;case"delete":s=["DELETE",a,"FROM",l];break;case"clear":s=["CLEAR",l];break;case"where":"function"==typeof n.limit&&(n.limit="[FUNCTION]"),s=["WHERE",JSON.stringify(n),"FROM",l]}r&&(s=s.concat(["INDEX",r])),this.handleLog({type:"request",data:s.join(" ")})}return this.handleLog({type:"transaction.end"})}},e}(),Connection.API},module.exports=factory()},function(e,n,t){var r,o,a=function(e,n){function t(){this.constructor=e}for(var r in n)i.call(n,r)&&(e[r]=n[r]);return t.prototype=n.prototype,e.prototype=new t,e.__super__=n.prototype,e},i={}.hasOwnProperty,s=[].slice;r=t(3),o=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return a(n,e),n.prototype.handleMethod=function(){var e,n;return n=arguments[0],e=2<=arguments.length?s.call(arguments,1):[],this.connection[n].apply(this.connection,e)},n.prototype.handleLogging=function(e){return this.handler=e,this.connection.logging.handleLog=function(e){return function(){return e.handleLog.apply(e,arguments)}}(this)},n}(r),e.exports=o},function(e,n){var t,r=[].slice;t=function(){function e(e){this.connection=e,this.proxyAPIMethods()}return e.prototype.proxyAPIMethods=function(e){var n,t,o;return null==e&&(e=[]),t=function(){var e,t;e=this.connection,t=[];for(n in e)o=e[n],"function"==typeof o&&t.push(n);return t}.call(this),t.forEach(function(e){return function(n){if("index"!==n)return e[n]=function(){return e.handleMethod.apply(e,[n].concat(r.call(arguments)))}}}(this))},e.prototype.index=function(e,n){return this.connection.createNamespaceForIndex(n,e,this)},e.prototype.handleLog=function(e){var n,t;if(this.handler){if(this.handler!==console)return this.handler(e);switch(t=e.type,n=e.data,t){case"transaction.start":return console.groupCollapsed(n);case"request":return console.log(n);case"transaction.end":return console.groupEnd()}}},e.prototype.proxyObjectStoresNamespace=function(e){return this.connection.createNamespaceForObjectStores(e,this)},e}(),e.exports=t},function(e,n,t){var r,o,a,i,s,u=function(e,n){return function(){return e.apply(n,arguments)}},c=function(e,n){function t(){this.constructor=e}for(var r in n)l.call(n,r)&&(e[r]=n[r]);return t.prototype=n.prototype,e.prototype=new t,e.__super__=n.prototype,e},l={}.hasOwnProperty,d=[].slice;r=t(3),a=t(5),o=t(6),s=t(7),i=function(e){function n(){this.handleMessage=u(this.handleMessage,this),n.__super__.constructor.apply(this,arguments),this.promises={},this.messages=[],this.id=1,this.spawnWorker()}return c(n,e),n.prototype.spawnWorker=function(){var e,n,t,r,i;return i=this.connection,r=i.name,t=i.migrations,t=a.stringifyFunctions(t),e=new Blob([o,s]),n=window.URL.createObjectURL(e),this.worker=new Worker(n),this.worker.onmessage=this.handleMessage,this.worker.postMessage({method:"init",args:{name:r,migrations:t}}),console.info("Ndex: Worker for “"+r+"” spawned at "+n)},n.prototype.handleLogging=function(e){return this.handler=e,this.worker.postMessage({method:"handleLogging"})},n.prototype.createPromiseForId=function(e){return new Promise(function(n){return function(t,r){return n.promises[e]={id:e,resolve:t,reject:r}}}(this))},n.prototype.handleMethod=function(){var e,n,t,r;return t=arguments[0],e=2<=arguments.length?d.call(arguments,1):[],n=this.id++,r=this.createPromiseForId(n),e=a.stringifyFunctions(e),this.messages.length||this.schedulePostMessage(),this.messages.push({id:n,method:t,args:e}),r},n.prototype.schedulePostMessage=function(){return setTimeout(function(e){return function(){var n;return n=e.messages.splice(0),e.worker.postMessage(n)}}(this),0)},n.prototype.handleMessage=function(e){var n,t,r,o,a,i,s;return a=e.data,t=a.id,s=a.resolve,i=a.reject,r=a.method,n=a.args,r?this[r](n):(o=this.promises[t],delete this.promises[t],"resolve"in e.data?o.resolve(s):o.reject(new Error(i)))},n}(r),e.exports=i},function(e,n){e.exports={stringifyFunctions:function(e,n){var t,r;if(null==n&&(n=[]),"function"==typeof e)return e.toString().replace(/\s\s+/g," ");if("object"==typeof e){if(n.indexOf(e)>=0);else{n.push(e);for(t in e)r=e[t],e[t]=this.stringifyFunctions(r,n)}return e}return e}}},function(e,n){e.exports="var factory,\n  slice = [].slice;\n\nfactory = function() {\n  var Connection;\n  Connection = {};\n  Connection.API = (function() {\n    function API(name1, migrations1) {\n      this.name = name1;\n      this.migrations = migrations1;\n      this.database = null;\n      this.queue = {};\n      this.logging = new Connection.Logging;\n    }\n\n    API.prototype.parseMigrations = function(migrations) {\n      var keys;\n      keys = Object.keys(migrations).sort();\n      return keys.map((function(_this) {\n        return function(k) {\n          var title, titleMatches, version;\n          version = parseInt(k);\n          titleMatches = k.match(/_(.+)/);\n          title = titleMatches ? titleMatches[1].replace(/(\\w)([A-Z])/g, function($1, $2, $3) {\n            return $2 + \" \" + ($3.toLowerCase());\n          }) : '';\n          return {\n            version: version,\n            title: title,\n            migration: migrations[k],\n            key: k\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.deleteDatabase = function() {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          var request;\n          if (!_this.database) {\n            return resolve();\n          }\n          _this.close();\n          request = indexedDB.deleteDatabase(_this.database.name);\n          return request.onsuccess = function(e) {\n            return setTimeout((function() {\n              return resolve();\n            }), 0);\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.open = function() {\n      if (this.dbPromise) {\n        return this.dbPromise;\n      }\n      return this.dbPromise = new Promise((function(_this) {\n        return function(resolve, reject) {\n          var e, migrations, request;\n          if (!self.indexedDB) {\n            return reject('indexedDB isn’t supported');\n          }\n          migrations = _this.parseMigrations(_this.migrations);\n          try {\n            request = indexedDB.open(_this.name, migrations.length + 1);\n          } catch (error) {\n            e = error;\n            return reject(e.message || e.name);\n          }\n          request.onupgradeneeded = function(e) {\n            var db, j, len, migration, migrationTransaction, results, transaction;\n            db = e.target.result;\n            transaction = e.target.transaction;\n            migrationTransaction = new Connection.Migration(db, transaction);\n            migrationTransaction.createObjectStore('migrations', {\n              keyPath: 'version'\n            });\n            results = [];\n            for (j = 0, len = migrations.length; j < len; j++) {\n              migration = migrations[j];\n              if (typeof migration.migration === 'string') {\n                migration.migration = eval(\"__\" + migration.key + \" = \" + migration.migration);\n              }\n              (migration.migration.up || migration.migration).bind(migrationTransaction).call();\n              delete migration.migration;\n              results.push(transaction.objectStore('migrations').put(migration));\n            }\n            return results;\n          };\n          request.onsuccess = function(e) {\n            var db, objectStoreNames;\n            db = e.target.result;\n            objectStoreNames = [].slice.call(db.objectStoreNames);\n            _this.createNamespaceForObjectStores(objectStoreNames);\n            db.onversionchange = function() {\n              return _this.close();\n            };\n            _this.database = db;\n            return resolve(objectStoreNames);\n          };\n          return request.onerror = function(e) {\n            return reject(request.error.message || request.error.name);\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.close = function() {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          if (_this.dbPromise) {\n            delete _this.dbPromise;\n          }\n          if (_this.database) {\n            _this.database.close();\n          }\n          return resolve();\n        };\n      })(this));\n    };\n\n    API.prototype.get = function(objectStoreName, key, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          var promises;\n          if (Array.isArray(key)) {\n            promises = Promise.all(key.map(function(k) {\n              return _this.get(objectStoreName, k);\n            }));\n            return promises.then(resolve);\n          } else {\n            return _this.enqueue('read', objectStoreName, function(transaction) {\n              var request;\n              _this.logging.addRequest(transaction, 'get', objectStoreName, indexName, {\n                key: key\n              });\n              request = _this.createRequest(transaction, objectStoreName, indexName);\n              return request.get(key).onsuccess = function(e) {\n                var value;\n                value = e.target.result;\n                if (value === void 0) {\n                  value = null;\n                }\n                return resolve(value);\n              };\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.getFirst = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          return _this.enqueue('read', objectStoreName, function(transaction) {\n            var request;\n            _this.logging.addRequest(transaction, 'getFirst', objectStoreName, indexName);\n            request = _this.createRequest(transaction, objectStoreName, indexName);\n            return request.openCursor().onsuccess = function(e) {\n              var cursor, value;\n              if (cursor = e.target.result) {\n                value = cursor.value;\n                if (!request.keyPath) {\n                  value._key = cursor.key;\n                }\n                return resolve(value);\n              } else {\n                return resolve(null);\n              }\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.getAll = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          return _this.enqueue('read', objectStoreName, function(transaction) {\n            var request, result;\n            _this.logging.addRequest(transaction, 'getAll', objectStoreName, indexName);\n            result = [];\n            request = _this.createRequest(transaction, objectStoreName, indexName);\n            return request.openCursor().onsuccess = function(e) {\n              var cursor, value;\n              if (!(cursor = e.target.result)) {\n                return resolve(result);\n              }\n              value = cursor.value;\n              if (!request.keyPath) {\n                value._key = cursor.key;\n              }\n              result.push(value);\n              return cursor[\"continue\"]();\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.add = function(objectStoreName, key, data) {\n      var ref;\n      if (data === void 0) {\n        ref = [null, key], key = ref[0], data = ref[1];\n      }\n      return new Promise((function(_this) {\n        return function(resolve) {\n          var promises;\n          if (!key && Array.isArray(data)) {\n            promises = Promise.all(data.map(function(d) {\n              return _this.add(objectStoreName, d);\n            }));\n            return promises.then(resolve);\n          } else if (key && Array.isArray(key) && Array.isArray(data)) {\n            promises = Promise.all(key.map(function(key, i) {\n              return _this.add(objectStoreName, key, data[i]);\n            }));\n            return promises.then(resolve);\n          } else {\n            return _this.enqueue('write', objectStoreName, function(transaction) {\n              var args, request;\n              _this.logging.addRequest(transaction, 'add', objectStoreName, null, {\n                key: key,\n                data: data\n              });\n              args = key ? [data, key] : [data];\n              request = _this.createRequest(transaction, objectStoreName);\n              return request.put.apply(request, args).onsuccess = function(e) {\n                data._key = e.target.result;\n                return resolve(data);\n              };\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.update = function(objectStoreName, key, value) {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          return _this.enqueue('write', objectStoreName, function(transaction) {\n            var getRequest;\n            _this.logging.addRequest(transaction, 'update', objectStoreName, null, {\n              key: key,\n              data: value\n            });\n            getRequest = _this.createRequest(transaction, objectStoreName);\n            return getRequest.get(key).onsuccess = function(e) {\n              var args, data, deepUpdate, hasKeyPath, keyPath, putRequest;\n              keyPath = e.target.source.keyPath;\n              hasKeyPath = !!keyPath;\n              data = e.target.result;\n              if (data === void 0) {\n                data = value;\n                if (hasKeyPath) {\n                  data[keyPath] = key;\n                }\n              } else {\n                deepUpdate = function(o, root) {\n                  var k, results, v;\n                  results = [];\n                  for (k in o) {\n                    v = o[k];\n                    if (typeof v === 'object') {\n                      deepUpdate(v, root[k]);\n                      continue;\n                    }\n                    results.push(root[k] = v);\n                  }\n                  return results;\n                };\n                deepUpdate(value, data);\n              }\n              args = hasKeyPath ? [data] : [data, key];\n              putRequest = _this.createRequest(transaction, objectStoreName);\n              return putRequest.put.apply(putRequest, args).onsuccess = function() {\n                return resolve(data);\n              };\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.increment = function(objectStoreName, key, value, decrement) {\n      if (value == null) {\n        value = 1;\n      }\n      return new Promise((function(_this) {\n        return function(resolve) {\n          return _this.enqueue('write', objectStoreName, function(transaction) {\n            var getRequest;\n            _this.logging.addRequest(transaction, (decrement ? 'decrement' : 'increment'), objectStoreName, null, {\n              key: key,\n              data: value\n            });\n            getRequest = _this.createRequest(transaction, objectStoreName);\n            return getRequest.get(key).onsuccess = function(e) {\n              var args, data, deepIncrement, hasKeyPath, keyPath, putRequest;\n              keyPath = e.target.source.keyPath;\n              hasKeyPath = !!keyPath;\n              data = e.target.result;\n              if (hasKeyPath) {\n                deepIncrement = function(o, root) {\n                  var k, results, v;\n                  results = [];\n                  for (k in o) {\n                    v = o[k];\n                    if (typeof v === 'object') {\n                      deepIncrement(v, root[k]);\n                      continue;\n                    }\n                    root[k] || (root[k] = 0);\n                    results.push(root[k] += decrement ? -v : v);\n                  }\n                  return results;\n                };\n                deepIncrement(value, data);\n              } else {\n                data || (data = 0);\n                data += decrement ? -value : value;\n              }\n              args = hasKeyPath ? [data] : [data, key];\n              putRequest = _this.createRequest(transaction, objectStoreName);\n              return putRequest.put.apply(putRequest, args).onsuccess = function() {\n                return resolve(data);\n              };\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.decrement = function(objectStoreName, key, value) {\n      return this.increment(objectStoreName, key, value, true);\n    };\n\n    API.prototype[\"delete\"] = function(objectStoreName, key) {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          var promises;\n          if (Array.isArray(key)) {\n            promises = Promise.all(key.map(function(k) {\n              return _this[\"delete\"](objectStoreName, k);\n            }));\n            return promises.then(resolve);\n          } else {\n            return _this.enqueue('write', objectStoreName, function(transaction) {\n              var request;\n              _this.logging.addRequest(transaction, 'delete', objectStoreName, null, {\n                key: key\n              });\n              request = _this.createRequest(transaction, objectStoreName);\n              return request[\"delete\"](key).onsuccess = function(e) {\n                return resolve(key);\n              };\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.deleteWhere = function(objectStoreName, predicates, indexName) {\n      predicates.remove = true;\n      return this.where(objectStoreName, predicates, indexName);\n    };\n\n    API.prototype.clear = function(objectStoreName) {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          return _this.enqueue('write', objectStoreName, function(transaction) {\n            var request;\n            _this.logging.addRequest(transaction, 'clear', objectStoreName);\n            request = _this.createRequest(transaction, objectStoreName);\n            return request.clear().onsuccess = function() {\n              return resolve();\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.clearAll = function() {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          var objectStoreNames, promises;\n          objectStoreNames = slice.call(_this.database.objectStoreNames);\n          objectStoreNames = objectStoreNames.filter(function(objectStoreName) {\n            return objectStoreName !== 'migrations';\n          });\n          promises = Promise.all(objectStoreNames.map(function(objectStoreName) {\n            return _this.clear(objectStoreName);\n          }));\n          return promises.then(resolve);\n        };\n      })(this));\n    };\n\n    API.prototype.reset = function(objectStoreName, key, data) {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          return _this.clear(objectStoreName).then(function() {\n            return _this.add(objectStoreName, key, data).then(resolve);\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.index = function(objectStoreName, indexName) {\n      return this.createNamespaceForIndex(indexName, objectStoreName);\n    };\n\n    API.prototype.where = function(objectStoreName, predicates, indexName) {\n      var readWrite;\n      readWrite = predicates.remove ? 'write' : 'read';\n      return new Promise((function(_this) {\n        return function(resolve) {\n          return _this.enqueue(readWrite, objectStoreName, function(transaction) {\n            var bound, bounds, contains, count, eq, eqIsArray, exact, except, gt, gteq, hasValues, isEquivalent, isInclusive, isLowerBound, k, knownUniques, limit, lower, lt, lteq, offset, only, order, range, ref, remove, request, result, uniq, uniques, upper, v;\n            _this.logging.addRequest(transaction, 'where', objectStoreName, indexName, {\n              data: predicates\n            });\n            lt = predicates.lt, lteq = predicates.lteq, gt = predicates.gt, gteq = predicates.gteq, eq = predicates.eq, limit = predicates.limit, offset = predicates.offset, only = predicates.only, contains = predicates.contains, except = predicates.except, uniq = predicates.uniq, order = predicates.order, remove = predicates.remove;\n            uniques = Array.isArray(uniq) ? uniq : uniq ? [uniq] : [];\n            order = order === 'desc' ? 'prev' : 'next';\n            bounds = {};\n            ref = {\n              lt: lt,\n              lteq: lteq,\n              gt: gt,\n              gteq: gteq,\n              eq: eq\n            };\n            for (k in ref) {\n              v = ref[k];\n              if (v === void 0) {\n                continue;\n              }\n              isInclusive = k === 'gteq' || k === 'lteq';\n              isEquivalent = k === 'eq';\n              isLowerBound = k === 'gt' || k === 'gteq';\n              bound = isEquivalent ? 'exact' : isLowerBound ? 'lower' : 'upper';\n              bounds[bound] = {\n                value: v,\n                open: !isInclusive\n              };\n            }\n            range = null;\n            eqIsArray = false;\n            lower = bounds.lower, upper = bounds.upper, exact = bounds.exact;\n            if (exact) {\n              if (eqIsArray = Array.isArray(eq)) {\n                eq.sort();\n                lower = {\n                  value: eq[0],\n                  open: false\n                };\n                upper = {\n                  value: eq[eq.length - 1],\n                  open: false\n                };\n                range = IDBKeyRange.bound(lower.value, upper.value, lower.open, upper.open);\n              } else {\n                range = IDBKeyRange.only(exact.value);\n              }\n            } else if (lower && upper) {\n              range = IDBKeyRange.bound(lower.value, upper.value, lower.open, upper.open);\n            } else if (lower) {\n              range = IDBKeyRange.lowerBound(lower.value, lower.open);\n            } else if (upper) {\n              range = IDBKeyRange.upperBound(upper.value, upper.open);\n            }\n            result = [];\n            count = 0;\n            knownUniques = {};\n            hasValues = function(object, k, v) {\n              if (!Array.isArray(v)) {\n                v = [v];\n              }\n              return v.indexOf(object[k]) !== -1;\n            };\n            request = _this.createRequest(transaction, objectStoreName, indexName);\n            request = range ? request.openCursor(range, order) : request.openCursor();\n            return request.onsuccess = function(e) {\n              var a, cursor, j, keyPath, knownValues, len, value;\n              if (!(cursor = e.target.result)) {\n                return resolve(result);\n              }\n              value = cursor.value;\n              if (eqIsArray) {\n                keyPath = e.target.source.keyPath;\n                only || (only = {});\n                only[keyPath] = eq;\n              }\n              for (k in only) {\n                v = only[k];\n                if (!hasValues(value, k, v)) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (k in contains) {\n                v = contains[k];\n                if (!Array.isArray(v)) {\n                  v = [v];\n                }\n                a = value[k];\n                if (!Array.isArray(a)) {\n                  a = [a];\n                }\n                if (!_this.intersect(a, v).length) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (k in except) {\n                v = except[k];\n                if (hasValues(value, k, v)) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (j = 0, len = uniques.length; j < len; j++) {\n                k = uniques[j];\n                knownValues = knownUniques[k] || (knownUniques[k] = []);\n                if (knownValues.indexOf(value[k]) !== -1) {\n                  return cursor[\"continue\"]();\n                }\n                knownUniques[k].push(value[k]);\n              }\n              count++;\n              if (offset && count <= offset) {\n                return cursor[\"continue\"]();\n              }\n              result.push(value);\n              if (remove) {\n                cursor[\"delete\"]();\n              }\n              if (limit) {\n                if (typeof limit === 'string') {\n                  limit = eval(\"__limit = \" + limit);\n                }\n                if (typeof limit === 'function' && limit(result)) {\n                  return resolve(result);\n                } else if (limit === result.length) {\n                  return resolve(result);\n                }\n              }\n              return cursor[\"continue\"]();\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.getMethodsForObjectStore = function() {\n      return this._getMethodsForObjectStore || (this._getMethodsForObjectStore = ['get', 'getFirst', 'getAll', 'add', 'update', 'increment', 'decrement', 'delete', 'deleteWhere', 'clear', 'reset', 'index', 'where']);\n    };\n\n    API.prototype.getMethodsForIndex = function() {\n      return this._getMethodsForIndex || (this._getMethodsForIndex = ['get', 'getFirst', 'getAll', 'where', 'deleteWhere']);\n    };\n\n    API.prototype.createNamespaceForObjectStores = function(objectStoreNames, context) {\n      var j, len, objectStoreName, results;\n      if (objectStoreNames == null) {\n        objectStoreNames = [];\n      }\n      if (context == null) {\n        context = this;\n      }\n      results = [];\n      for (j = 0, len = objectStoreNames.length; j < len; j++) {\n        objectStoreName = objectStoreNames[j];\n        if (objectStoreName === 'migrations') {\n          continue;\n        }\n        results.push(this.createNamespaceForObjectStore(objectStoreName, context));\n      }\n      return results;\n    };\n\n    API.prototype.createNamespaceForObjectStore = function(objectStoreName, context) {\n      var namespace;\n      if (context == null) {\n        context = this;\n      }\n      namespace = context[objectStoreName] = {};\n      this.getMethodsForObjectStore().forEach((function(_this) {\n        return function(method) {\n          return namespace[method] = function() {\n            return context[method].apply(context, [objectStoreName].concat(slice.call(arguments)));\n          };\n        };\n      })(this));\n      return namespace;\n    };\n\n    API.prototype.createNamespaceForIndex = function(indexName, objectStoreName, context) {\n      var namespace;\n      if (context == null) {\n        context = this;\n      }\n      namespace = {};\n      this.getMethodsForIndex().forEach((function(_this) {\n        return function(method) {\n          return namespace[method] = function() {\n            return context[method].apply(context, [objectStoreName].concat(slice.call(arguments), [indexName]));\n          };\n        };\n      })(this));\n      return namespace;\n    };\n\n    API.prototype.createRequest = function(transaction, objectStoreName, indexName) {\n      var objectStore;\n      objectStore = transaction.objectStore(objectStoreName);\n      if (indexName) {\n        return objectStore.index(indexName);\n      } else {\n        return objectStore;\n      }\n    };\n\n    API.prototype.createTransaction = function(mode, objectStoreName, callback) {\n      return this.open().then((function(_this) {\n        return function() {\n          var transaction;\n          transaction = _this.database.transaction([objectStoreName], mode);\n          return callback(transaction);\n        };\n      })(this))[\"catch\"]((function(_this) {\n        return function(err) {\n          throw err;\n        };\n      })(this));\n    };\n\n    API.prototype.intersect = function(a, b) {\n      var ai, bi, result;\n      ai = 0;\n      bi = 0;\n      result = [];\n      while (ai < a.length && bi < b.length) {\n        if (a[ai] < b[bi]) {\n          ai++;\n        } else if (a[ai] > b[bi]) {\n          bi++;\n        } else {\n          result.push(a[ai]);\n          ai++;\n          bi++;\n        }\n      }\n      return result;\n    };\n\n    API.prototype.enqueue = function(readwrite, objectStoreName, callback) {\n      var base, request;\n      (base = this.queue)[objectStoreName] || (base[objectStoreName] = []);\n      request = {\n        readwrite: readwrite,\n        callback: callback\n      };\n      if (!this.queue[objectStoreName].length) {\n        this.scheduleTransaction(objectStoreName);\n      }\n      return this.queue[objectStoreName].push(request);\n    };\n\n    API.prototype.scheduleTransaction = function(objectStoreName) {\n      return setTimeout((function(_this) {\n        return function() {\n          var mode, modes, needsWriteMode, requests;\n          requests = _this.queue[objectStoreName].splice(0);\n          modes = requests.map(function(r) {\n            return r.readwrite;\n          });\n          needsWriteMode = modes.some(function(m) {\n            return m === 'write';\n          });\n          mode = needsWriteMode ? 'readwrite' : 'readonly';\n          return _this.createTransaction(mode, objectStoreName, function(transaction) {\n            var j, len, request, results;\n            _this.logging.addTransaction(transaction, objectStoreName);\n            results = [];\n            for (j = 0, len = requests.length; j < len; j++) {\n              request = requests[j];\n              results.push(request.callback(transaction));\n            }\n            return results;\n          });\n        };\n      })(this), 0);\n    };\n\n    return API;\n\n  })();\n  Connection.Migration = (function() {\n    function Migration(db1, transaction1) {\n      this.db = db1;\n      this.transaction = transaction1;\n    }\n\n    Migration.prototype.createObjectStore = function(name, options) {\n      if (this.db.objectStoreNames.contains(name)) {\n        return;\n      }\n      return this.db.createObjectStore(name, options);\n    };\n\n    Migration.prototype.deleteObjectStore = function(name) {\n      if (!this.db.objectStoreNames.contains(name)) {\n        return;\n      }\n      return this.db.deleteObjectStore(name);\n    };\n\n    Migration.prototype.createIndex = function(objectStoreName, indexName, keyPath, options) {\n      var objectStore;\n      objectStore = this.transaction.objectStore(objectStoreName);\n      if (objectStore && objectStore.indexNames.contains(indexName)) {\n        return;\n      }\n      return objectStore.createIndex(indexName, keyPath, options);\n    };\n\n    Migration.prototype.deleteIndex = function(objectStoreName, indexName) {\n      var objectStore;\n      objectStore = this.transaction.objectStore(objectStoreName);\n      if (!(objectStore && objectStore.indexNames.contains(indexName))) {\n        return;\n      }\n      return objectStore.deleteIndex(indexName);\n    };\n\n    return Migration;\n\n  })();\n  Connection.Logging = (function() {\n    function Logging() {\n      this.queues = [];\n    }\n\n    Logging.prototype.addTransaction = function(transaction, objectStoreNames) {\n      var callback;\n      if (!this.handleLog) {\n        return;\n      }\n      this.queues.push({\n        transaction: transaction,\n        objectStoreNames: objectStoreNames,\n        requests: [],\n        start: Date.now()\n      });\n      callback = (function(_this) {\n        return function(e) {\n          return _this.logTransaction(e.target);\n        };\n      })(this);\n      transaction.onabort = callback;\n      transaction.onerror = callback;\n      return transaction.oncomplete = callback;\n    };\n\n    Logging.prototype.addRequest = function(transaction, method, objectStoreName, indexName, data) {\n      var queue;\n      if (!this.handleLog) {\n        return;\n      }\n      queue = this.queues.filter(function(q) {\n        return q.transaction === transaction;\n      })[0];\n      if (!queue) {\n        return;\n      }\n      return queue.requests.push({\n        method: method,\n        objectStoreName: objectStoreName,\n        indexName: indexName,\n        data: data\n      });\n    };\n\n    Logging.prototype.logTransaction = function(transaction) {\n      var data, end, indexName, j, key, len, logs, method, mode, objectStoreName, queue, ref, ref1, request, requestsLenght, time;\n      if (!this.handleLog) {\n        return;\n      }\n      queue = this.queues.filter(function(q) {\n        return q.transaction === transaction;\n      })[0];\n      if (!queue) {\n        return;\n      }\n      mode = queue.transaction.mode === 'readwrite' ? 'write' : 'read ';\n      requestsLenght = queue.requests.length;\n      end = Date.now();\n      time = end - queue.start;\n      this.handleLog({\n        type: 'transaction.start',\n        data: \"Ndex: \" + mode + \" \" + queue.objectStoreNames + \" \" + time + \"ms (\" + requestsLenght + \" request\" + (requestsLenght > 1 ? 's' : '') + \")\"\n      });\n      ref = queue.requests;\n      for (j = 0, len = ref.length; j < len; j++) {\n        request = ref[j];\n        method = request.method, objectStoreName = request.objectStoreName, indexName = request.indexName, data = request.data;\n        if (data) {\n          ref1 = data, key = ref1.key, data = ref1.data;\n        }\n        logs = [];\n        switch (method) {\n          case 'get':\n            logs = ['GET', key, 'FROM', objectStoreName];\n            break;\n          case 'getFirst':\n            logs = ['GET FIRST', key, 'FROM', objectStoreName];\n            break;\n          case 'getAll':\n            logs = ['GET ALL', 'FROM', objectStoreName];\n            break;\n          case 'add':\n            logs = ['ADD', JSON.stringify(data), 'TO', objectStoreName];\n            if (key) {\n              logs = logs.concat(['WITH KEY', key]);\n            }\n            break;\n          case 'update':\n            logs = ['UPDATE', key, 'FROM', objectStoreName, 'SET', JSON.stringify(data)];\n            break;\n          case 'increment':\n            if (typeof data === 'object') {\n              data = JSON.stringify(data);\n            }\n            logs = ['INCREMENT', data, 'TO KEY', key, 'FROM', objectStoreName];\n            break;\n          case 'decrement':\n            if (typeof data === 'object') {\n              data = JSON.stringify(data);\n            }\n            logs = ['DECREMENT', data, 'TO KEY', key, 'FROM', objectStoreName];\n            break;\n          case 'delete':\n            logs = ['DELETE', key, 'FROM', objectStoreName];\n            break;\n          case 'clear':\n            logs = ['CLEAR', objectStoreName];\n            break;\n          case 'where':\n            if (typeof data.limit === 'function') {\n              data.limit = '[FUNCTION]';\n            }\n            logs = ['WHERE', JSON.stringify(data), 'FROM', objectStoreName];\n        }\n        if (indexName) {\n          logs = logs.concat(['INDEX', indexName]);\n        }\n        this.handleLog({\n          type: 'request',\n          data: logs.join(' ')\n        });\n      }\n      return this.handleLog({\n        type: 'transaction.end'\n      });\n    };\n\n    return Logging;\n\n  })();\n  return Connection.API;\n};\n\nif (typeof exports !== 'undefined') {\n  module.exports = factory();\n} else {\n  this.Connection = factory();\n}\n";
},function(e,n){e.exports="var handleLogging, init;\n\ninit = function(arg) {\n  var migrations, name;\n  name = arg.name, migrations = arg.migrations;\n  return this.connection = new Connection(name, migrations);\n};\n\nhandleLogging = function() {\n  return this.connection.logging.handleLog = function(args) {\n    return postMessage({\n      method: 'handleLog',\n      args: args\n    });\n  };\n};\n\nself.onmessage = (function(_this) {\n  return function(e) {\n    var data;\n    data = e.data;\n    if (!Array.isArray(data)) {\n      data = [data];\n    }\n    return data.forEach(function(datum) {\n      var args, id, method;\n      id = datum.id, method = datum.method, args = datum.args;\n      if (typeof _this[method] === 'function') {\n        return _this[method](args);\n      }\n      return _this.connection[method].apply(_this.connection, args).then(function(data) {\n        return postMessage({\n          id: id,\n          resolve: data\n        });\n      })[\"catch\"](function(data) {\n        return postMessage({\n          id: id,\n          reject: data\n        });\n      });\n    });\n  };\n})(this);\n"}])});