!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Ndex=t():e.Ndex=t()}(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,t),o.loaded=!0,o.exports}var n={};return t.m=e,t.c=n,t.p="",t(0)}([function(e,t,n){var r,o,i,a;o=n(1),r=n(2),a=n(4),i=function(){function e(){this.connections={}}return e.prototype.connect=function(e,t,n){return null==n&&(n=null),new Promise(function(i){return function(s,u){var c;if(!n){if(c=i.connections[e])return u(new Error("Already connected to “"+e+"”"));c=new o(e,t),n=i.connections[e]=i.getAdapter(c)}return n.handleMethod("open").then(function(e){return n.proxyObjectStoresNamespace(e),s(n)}).catch(function(t){return n instanceof a?(n=i.connections[e]=new r(c),console.info("Ndex: Fallbacking to BrowserAdapter for “"+e+"” because “"+t+"”"),s(i.connect(null,null,n))):u("Ndex: "+t)})}}(this))},e.prototype.getAdapter=function(e){var t;return new(t=this.getAdapterClass())(e)},e.prototype.getAdapterClass=function(){return this.workersAreSupported()?a:r},e.prototype.workersAreSupported=function(e){return null==e&&(e=window),null!=this._workersAreSupported?this._workersAreSupported:this._workersAreSupported="Worker"in e},e}(),e.exports=new i},function(module,exports,__webpack_require__){var factory,slice=[].slice;factory=function(){var Connection;return Connection={},Connection.API=function(){function API(e,t){this.name=e,this.migrations=t,this.database=null,this.queue={},this.logging=new Connection.Logging}return API.prototype.CONNECTION_TIMEOUT=3e3,API.prototype.REQUEST_TIMEOUT=3e3,API.prototype.parseMigrations=function(e){var t;return t=Object.keys(e).sort(),t.map(function(t){return function(t){var n,r,o;return o=parseInt(t),r=t.match(/_(.+)/),n=r?r[1].replace(/(\w)([A-Z])/g,function(e,t,n){return t+" "+n.toLowerCase()}):"",{version:o,title:n,migration:e[t],key:t}}}(this))},API.prototype.deleteDatabase=function(){return new Promise(function(e){return function(t){var n;return e.database?(e.close(),n=indexedDB.deleteDatabase(e.database.name),n.onsuccess=function(e){return setTimeout(function(){return t()},0)}):t()}}(this))},API.prototype.open=function(){return this.dbPromise?this.dbPromise:this.dbPromise=new Promise(function(_this){return function(resolve,reject){var e,migrations,request;if(!self.indexedDB)return reject("indexedDB isn’t supported");migrations=_this.parseMigrations(_this.migrations);try{request=indexedDB.open(_this.name,migrations.length+1),null!=_this.CONNECTION_TIMEOUT&&_this.CONNECTION_TIMEOUT>-1&&(request.__timeout=setTimeout(function(){return request.__timedout=!0,reject(new Error("Connection timed out"))},_this.CONNECTION_TIMEOUT))}catch(t){return e=t,clearTimeout(request.__timeout),reject(e.message||e.name)}return request.onupgradeneeded=function(e){var db,j,len,migration,migrationTransaction,results,transaction;if(clearTimeout(request.__timeout),!request.__timedout){for(db=e.target.result,transaction=e.target.transaction,migrationTransaction=new Connection.Migration(db,transaction),migrationTransaction.createObjectStore("migrations",{keyPath:"version"}),results=[],j=0,len=migrations.length;j<len;j++)migration=migrations[j],"string"==typeof migration.migration&&(migration.migration=eval("__"+migration.key+" = "+migration.migration)),(migration.migration.up||migration.migration).bind(migrationTransaction).call(),delete migration.migration,results.push(transaction.objectStore("migrations").put(migration));return results}},request.onsuccess=function(e){var t,n;if(clearTimeout(request.__timeout),!request.__timedout)return t=e.target.result,n=[].slice.call(t.objectStoreNames),_this.createNamespaceForObjectStores(n),t.onversionchange=function(){return _this.close()},_this.database=t,resolve(n)},request.onerror=function(e){return reject(request.error.message||request.error.name)}}}(this))},API.prototype.close=function(){return new Promise(function(e){return function(t){return e.dbPromise&&delete e.dbPromise,e.database&&e.database.close(),t()}}(this))},API.prototype.get=function(e,t,n){return new Promise(function(r){return function(o,i){var a;return Array.isArray(t)?(a=Promise.all(t.map(function(t){return r.get(e,t)})),a.then(o)):r.enqueue("read",e,function(a){var s;return r.logging.addRequest(a,"get",e,n,{key:t}),s=r.createRequest({transaction:a,objectStoreName:e,indexName:n,reject:i}),s.get(t).onsuccess=function(e){var t;if(clearTimeout(s.__timeout),!s.__timedout)return t=e.target.result,void 0===t&&(t=null),o(t)}})}}(this))},API.prototype.getFirst=function(e,t){return new Promise(function(n){return function(r,o){return n.enqueue("read",e,function(i){var a;return n.logging.addRequest(i,"getFirst",e,t),a=n.createRequest({transaction:i,objectStoreName:e,indexName:t,reject:o}),a.openCursor().onsuccess=function(e){var t,n;if(clearTimeout(a.__timeout),!a.__timedout)return(t=e.target.result)?(n=t.value,a.keyPath||(n._key=t.key),r(n)):r(null)}})}}(this))},API.prototype.getAll=function(e,t){return new Promise(function(n){return function(r,o){return n.enqueue("read",e,function(i){var a,s;return n.logging.addRequest(i,"getAll",e,t),s=[],a=n.createRequest({transaction:i,objectStoreName:e,indexName:t,reject:o}),a.openCursor().onsuccess=function(e){var t,n;if(clearTimeout(a.__timeout),!a.__timedout)return(t=e.target.result)?(n=t.value,a.keyPath||(n._key=t.key),s.push(n),t.continue()):r(s)}})}}(this))},API.prototype.count=function(e,t){return new Promise(function(n){return function(r,o){return n.enqueue("read",e,function(i){var a;return n.logging.addRequest(i,"count",e,t),a=n.createRequest({transaction:i,objectStoreName:e,indexName:t,reject:o}),a.count().onsuccess=function(e){var t;if(clearTimeout(a.__timeout),!a.__timedout)return t=e.target.result,t||(t=0),r(t)}})}}(this))},API.prototype.add=function(e,t,n){var r;return void 0===n&&(r=[null,t],t=r[0],n=r[1]),new Promise(function(r){return function(o,i){var a;return!t&&Array.isArray(n)?(a=Promise.all(n.map(function(t){return r.add(e,t)})),a.then(o)):t&&Array.isArray(t)&&Array.isArray(n)?(a=Promise.all(t.map(function(t,o){return r.add(e,t,n[o])})),a.then(o)):r.enqueue("write",e,function(a){var s,u;return r.logging.addRequest(a,"add",e,null,{key:t,data:n}),s=t?[n,t]:[n],u=r.createRequest({transaction:a,objectStoreName:e,reject:i}),u.put.apply(u,s).onsuccess=function(e){if(clearTimeout(u.__timeout),!u.__timedout)return n._key=e.target.result,o(n)}})}}(this))},API.prototype.update=function(e,t,n){return new Promise(function(r){return function(o,i){return r.enqueue("write",e,function(a){var s;return r.logging.addRequest(a,"update",e,null,{key:t,data:n}),s=r.createRequest({transaction:a,objectStoreName:e,reject:i}),s.get(t).onsuccess=function(u){var c,l,d,m,f,p;if(clearTimeout(s.__timeout),!s.__timedout)return f=u.target.source.keyPath,m=!!f,l=u.target.result,void 0===l?(l=n,m&&(l[f]=t)):(d=function(e,t){var n,r,o;r=[];for(n in e)o=e[n],"object"!=typeof o?r.push(t[n]=o):d(o,t[n]);return r})(n,l),c=m?[l]:[l,t],p=r.createRequest({transaction:a,objectStoreName:e,reject:i}),p.put.apply(p,c).onsuccess=function(){if(clearTimeout(p.__timeout),!p.__timedout)return o(l)}}})}}(this))},API.prototype.increment=function(e,t,n,r){return null==n&&(n=1),new Promise(function(o){return function(i,a){return o.enqueue("write",e,function(s){var u;return o.logging.addRequest(s,r?"decrement":"increment",e,null,{key:t,data:n}),u=o.createRequest({transaction:s,objectStoreName:e,reject:a}),u.get(t).onsuccess=function(c){var l,d,m,f,p,h;if(clearTimeout(u.__timeout),!u.__timedout)return p=c.target.source.keyPath,f=!!p,d=c.target.result,f?(m=function(e,t){var n,o,i;o=[];for(n in e)i=e[n],"object"!=typeof i?(t[n]||(t[n]=0),o.push(t[n]+=r?-i:i)):m(i,t[n]);return o})(n,d):(d||(d=0),d+=r?-n:n),l=f?[d]:[d,t],h=o.createRequest({transaction:s,objectStoreName:e,reject:a}),h.put.apply(h,l).onsuccess=function(){if(clearTimeout(h.__timeout),!h.__timedout)return i(d)}}})}}(this))},API.prototype.decrement=function(e,t,n){return this.increment(e,t,n,!0)},API.prototype.delete=function(e,t){return new Promise(function(n){return function(r,o){var i;return Array.isArray(t)?(i=Promise.all(t.map(function(t){return n.delete(e,t)})),i.then(r)):n.enqueue("write",e,function(i){var a;return n.logging.addRequest(i,"delete",e,null,{key:t}),a=n.createRequest({transaction:i,objectStoreName:e,reject:o}),a.delete(t).onsuccess=function(e){if(clearTimeout(a.__timeout),!a.__timedout)return r(t)}})}}(this))},API.prototype.deleteWhere=function(e,t,n){return t.remove=!0,this.where(e,t,n)},API.prototype.clear=function(e){return new Promise(function(t){return function(n,r){return t.enqueue("write",e,function(o){var i;return t.logging.addRequest(o,"clear",e),i=t.createRequest({transaction:o,objectStoreName:e,reject:r}),i.clear().onsuccess=function(){if(clearTimeout(i.__timeout),!i.__timedout)return n()}})}}(this))},API.prototype.clearAll=function(){return new Promise(function(e){return function(t,n){var r,o;return r=slice.call(e.database.objectStoreNames),r=r.filter(function(e){return"migrations"!==e}),o=Promise.all(r.map(function(t){return e.clear(t)})),o.then(t),o.catch(n)}}(this))},API.prototype.reset=function(e,t,n){return new Promise(function(r){return function(o,i){var a;return a=r.clear(e),a.catch(i),a.then(function(){var a;return a=r.add(e,t,n),a.catch(i),a.then(o)})}}(this))},API.prototype.index=function(e,t){return this.createNamespaceForIndex(t,e)},API.prototype.where=function(objectStoreName,predicates,indexName){var readWrite;return readWrite=predicates.remove?"write":"read",new Promise(function(_this){return function(resolve,reject){return _this.enqueue(readWrite,objectStoreName,function(transaction){var bound,bounds,contains,count,eq,eqIsArray,exact,except,gt,gteq,hasValues,isEquivalent,isInclusive,isLowerBound,k,knownUniques,limit,lower,lt,lteq,offset,only,order,range,ref,remove,request,result,uniq,uniques,upper,v;_this.logging.addRequest(transaction,"where",objectStoreName,indexName,{data:predicates}),lt=predicates.lt,lteq=predicates.lteq,gt=predicates.gt,gteq=predicates.gteq,eq=predicates.eq,limit=predicates.limit,offset=predicates.offset,only=predicates.only,contains=predicates.contains,except=predicates.except,uniq=predicates.uniq,order=predicates.order,remove=predicates.remove,uniques=Array.isArray(uniq)?uniq:uniq?[uniq]:[],order="desc"===order?"prev":"next",bounds={},ref={lt:lt,lteq:lteq,gt:gt,gteq:gteq,eq:eq};for(k in ref)v=ref[k],void 0!==v&&(isInclusive="gteq"===k||"lteq"===k,isEquivalent="eq"===k,isLowerBound="gt"===k||"gteq"===k,bound=isEquivalent?"exact":isLowerBound?"lower":"upper",bounds[bound]={value:v,open:!isInclusive});return range=null,eqIsArray=!1,lower=bounds.lower,upper=bounds.upper,exact=bounds.exact,exact?(eqIsArray=Array.isArray(eq))?(eq.sort(),lower={value:eq[0],open:!1},upper={value:eq[eq.length-1],open:!1},range=IDBKeyRange.bound(lower.value,upper.value,lower.open,upper.open)):range=IDBKeyRange.only(exact.value):lower&&upper?range=IDBKeyRange.bound(lower.value,upper.value,lower.open,upper.open):lower?range=IDBKeyRange.lowerBound(lower.value,lower.open):upper&&(range=IDBKeyRange.upperBound(upper.value,upper.open)),result=[],count=0,knownUniques={},hasValues=function(e,t,n){return Array.isArray(n)||(n=[n]),n.indexOf(e[t])!==-1},request=_this.createRequest({transaction:transaction,objectStoreName:objectStoreName,indexName:indexName,reject:reject}),request=range?request.openCursor(range,order):request.openCursor(),request.onsuccess=function(e){var a,cursor,j,keyPath,knownValues,len,value;if(clearTimeout(request.__timeout),!request.__timedout){if(!(cursor=e.target.result))return resolve(result);value=cursor.value,eqIsArray&&(keyPath=e.target.source.keyPath,only||(only={}),only[keyPath]=eq);for(k in only)if(v=only[k],!hasValues(value,k,v))return cursor.continue();for(k in contains)if(v=contains[k],Array.isArray(v)||(v=[v]),a=value[k],Array.isArray(a)||(a=[a]),!_this.intersect(a,v).length)return cursor.continue();for(k in except)if(v=except[k],hasValues(value,k,v))return cursor.continue();for(j=0,len=uniques.length;j<len;j++){if(k=uniques[j],knownValues=knownUniques[k]||(knownUniques[k]=[]),knownValues.indexOf(value[k])!==-1)return cursor.continue();knownUniques[k].push(value[k])}if(count++,offset&&count<=offset)return cursor.continue();if(result.push(value),remove&&cursor.delete(),limit){if("string"==typeof limit&&(limit=eval("__limit = "+limit)),"function"==typeof limit&&limit(result))return resolve(result);if(limit===result.length)return resolve(result)}return cursor.continue()}}})}}(this))},API.prototype.getMethodsForObjectStore=function(){return this._getMethodsForObjectStore||(this._getMethodsForObjectStore=["get","getFirst","getAll","count","add","update","increment","decrement","delete","deleteWhere","clear","reset","index","where"])},API.prototype.getMethodsForIndex=function(){return this._getMethodsForIndex||(this._getMethodsForIndex=["get","getFirst","getAll","count","where","deleteWhere"])},API.prototype.createNamespaceForObjectStores=function(e,t){var n,r,o,i;for(null==e&&(e=[]),null==t&&(t=this),i=[],n=0,r=e.length;n<r;n++)o=e[n],"migrations"!==o&&i.push(this.createNamespaceForObjectStore(o,t));return i},API.prototype.createNamespaceForObjectStore=function(e,t){var n;return null==t&&(t=this),n=t[e]={},this.getMethodsForObjectStore().forEach(function(r){return function(r){return n[r]=function(){return t[r].apply(t,[e].concat(slice.call(arguments)))}}}(this)),n},API.prototype.createNamespaceForIndex=function(e,t,n){var r;return null==n&&(n=this),r={},this.getMethodsForIndex().forEach(function(o){return function(o){return r[o]=function(){return n[o].apply(n,[t].concat(slice.call(arguments),[e]))}}}(this)),r},API.prototype.createRequest=function(e){var t,n,r,o,i,a;return a=e.transaction,r=e.objectStoreName,t=e.indexName,o=e.reject,n=a.objectStore(r),i=t?n.index(t):n,o&&null!=this.REQUEST_TIMEOUT&&this.REQUEST_TIMEOUT>-1&&(i.__timeout=setTimeout(function(){return i.__timedout=!0,o(new Error("Request timed out"))},this.REQUEST_TIMEOUT)),i},API.prototype.createTransaction=function(e,t,n){return this.open().then(function(r){return function(){var o;return o=r.database.transaction([t],e),n(o)}}(this)).catch(function(e){return function(e){throw e}}(this))},API.prototype.intersect=function(e,t){var n,r,o;for(n=0,r=0,o=[];n<e.length&&r<t.length;)e[n]<t[r]?n++:e[n]>t[r]?r++:(o.push(e[n]),n++,r++);return o},API.prototype.enqueue=function(e,t,n){var r,o;return(r=this.queue)[t]||(r[t]=[]),o={readwrite:e,callback:n},this.queue[t].length||this.scheduleTransaction(t),this.queue[t].push(o)},API.prototype.scheduleTransaction=function(e){return setTimeout(function(t){return function(){var n,r,o,i;return i=t.queue[e].splice(0),r=i.map(function(e){return e.readwrite}),o=r.some(function(e){return"write"===e}),n=o?"readwrite":"readonly",t.createTransaction(n,e,function(n){var r,o,a,s;for(t.logging.addTransaction(n,e),s=[],r=0,o=i.length;r<o;r++)a=i[r],s.push(a.callback(n));return s})}}(this),0)},API}(),Connection.Migration=function(){function e(e,t){this.db=e,this.transaction=t}return e.prototype.createObjectStore=function(e,t){if(!this.db.objectStoreNames.contains(e))return this.db.createObjectStore(e,t)},e.prototype.deleteObjectStore=function(e){if(this.db.objectStoreNames.contains(e))return this.db.deleteObjectStore(e)},e.prototype.createIndex=function(e,t,n,r){var o;if(o=this.transaction.objectStore(e),!o||!o.indexNames.contains(t))return o.createIndex(t,n,r)},e.prototype.deleteIndex=function(e,t){var n;if(n=this.transaction.objectStore(e),n&&n.indexNames.contains(t))return n.deleteIndex(t)},e}(),Connection.Logging=function(){function e(){this.queues=[]}return e.prototype.addTransaction=function(e,t){var n;if(this.handleLog)return this.queues.push({transaction:e,objectStoreNames:t,requests:[],start:Date.now()}),n=function(e){return function(t){return e.logTransaction(t.target)}}(this),e.onabort=n,e.onerror=n,e.oncomplete=n},e.prototype.addRequest=function(e,t,n,r,o){var i;if(this.handleLog&&(i=this.queues.filter(function(t){return t.transaction===e})[0]))return i.requests.push({method:t,objectStoreName:n,indexName:r,data:o})},e.prototype.logTransaction=function(e){var t,n,r,o,i,a,s,u,c,l,d,m,f,p,h,g;if(this.handleLog&&(d=this.queues.filter(function(t){return t.transaction===e})[0])){for(c="readwrite"===d.transaction.mode?"write":"read ",h=d.requests.length,n=Date.now(),g=n-d.start,this.handleLog({type:"transaction.start",data:"Ndex: "+c+" "+d.objectStoreNames+" "+g+"ms ("+h+" request"+(h>1?"s":"")+")"}),m=d.requests,o=0,a=m.length;o<a;o++){switch(p=m[o],u=p.method,l=p.objectStoreName,r=p.indexName,t=p.data,t&&(f=t,i=f.key,t=f.data),s=[],u){case"get":s=["GET",i,"FROM",l];break;case"getFirst":s=["GET FIRST",i,"FROM",l];break;case"getAll":s=["GET ALL","FROM",l];break;case"count":s=["COUNT","FROM",l];break;case"add":s=["ADD",JSON.stringify(t),"TO",l],i&&(s=s.concat(["WITH KEY",i]));break;case"update":s=["UPDATE",i,"FROM",l,"SET",JSON.stringify(t)];break;case"increment":"object"==typeof t&&(t=JSON.stringify(t)),s=["INCREMENT",t,"TO KEY",i,"FROM",l];break;case"decrement":"object"==typeof t&&(t=JSON.stringify(t)),s=["DECREMENT",t,"TO KEY",i,"FROM",l];break;case"delete":s=["DELETE",i,"FROM",l];break;case"clear":s=["CLEAR",l];break;case"where":"function"==typeof t.limit&&(t.limit="[FUNCTION]"),s=["WHERE",JSON.stringify(t),"FROM",l]}r&&(s=s.concat(["INDEX",r])),this.handleLog({type:"request",data:s.join(" ")})}return this.handleLog({type:"transaction.end"})}},e}(),Connection.API},module.exports=factory()},function(e,t,n){var r,o,i=function(e,t){function n(){this.constructor=e}for(var r in t)a.call(t,r)&&(e[r]=t[r]);return n.prototype=t.prototype,e.prototype=new n,e.__super__=t.prototype,e},a={}.hasOwnProperty,s=[].slice;r=n(3),o=function(e){function t(){return t.__super__.constructor.apply(this,arguments)}return i(t,e),t.prototype.handleMethod=function(){var e,t;return t=arguments[0],e=2<=arguments.length?s.call(arguments,1):[],this.connection[t].apply(this.connection,e)},t.prototype.handleLogging=function(e){return this.handler=e,this.connection.logging.handleLog=function(e){return function(){return e.handleLog.apply(e,arguments)}}(this)},t}(r),e.exports=o},function(e,t){var n,r=[].slice;n=function(){function e(e){this.connection=e,this.proxyAPIMethods()}return e.prototype.proxyAPIMethods=function(e){var t,n,o;return null==e&&(e=[]),n=function(){var e,n;e=this.connection,n=[];for(t in e)o=e[t],"function"==typeof o&&n.push(t);return n}.call(this),n.forEach(function(e){return function(t){if("index"!==t)return e[t]=function(){return e.handleMethod.apply(e,[t].concat(r.call(arguments)))}}}(this))},e.prototype.index=function(e,t){return this.connection.createNamespaceForIndex(t,e,this)},e.prototype.handleLog=function(e){var t,n;if(this.handler){if(this.handler!==console)return this.handler(e);switch(n=e.type,t=e.data,n){case"transaction.start":return console.groupCollapsed(t);case"request":return console.log(t);case"transaction.end":return console.groupEnd()}}},e.prototype.proxyObjectStoresNamespace=function(e){return this.connection.createNamespaceForObjectStores(e,this)},e}(),e.exports=n},function(e,t,n){var r,o,i,a,s,u=function(e,t){return function(){return e.apply(t,arguments)}},c=function(e,t){function n(){this.constructor=e}for(var r in t)l.call(t,r)&&(e[r]=t[r]);return n.prototype=t.prototype,e.prototype=new n,e.__super__=t.prototype,e},l={}.hasOwnProperty,d=[].slice;r=n(3),i=n(5),o=n(6),s=n(7),a=function(e){function t(){this.handleMessage=u(this.handleMessage,this),t.__super__.constructor.apply(this,arguments),this.promises={},this.messages=[],this.id=1,this.spawnWorker()}return c(t,e),t.prototype.spawnWorker=function(){var e,t,n,r,a;return a=this.connection,r=a.name,n=a.migrations,n=i.stringifyFunctions(n),e=new Blob([o,s]),t=window.URL.createObjectURL(e),this.worker=new Worker(t),this.worker.onmessage=this.handleMessage,this.worker.postMessage({method:"init",args:{name:r,migrations:n}}),console.info("Ndex: Worker for “"+r+"” spawned at "+t)},t.prototype.handleLogging=function(e){return this.handler=e,this.worker.postMessage({method:"handleLogging"})},t.prototype.createPromiseForId=function(e){return new Promise(function(t){return function(n,r){return t.promises[e]={id:e,resolve:n,reject:r}}}(this))},t.prototype.handleMethod=function(){var e,t,n,r;return n=arguments[0],e=2<=arguments.length?d.call(arguments,1):[],t=this.id++,r=this.createPromiseForId(t),e=i.stringifyFunctions(e),this.messages.length||this.schedulePostMessage(),this.messages.push({id:t,method:n,args:e}),r},t.prototype.schedulePostMessage=function(){return setTimeout(function(e){return function(){var t;return t=e.messages.splice(0),e.worker.postMessage(t)}}(this),0)},t.prototype.handleMessage=function(e){var t,n,r,o,i,a,s;return i=e.data,n=i.id,s=i.resolve,a=i.reject,r=i.method,t=i.args,r?this[r](t):(o=this.promises[n],delete this.promises[n],"resolve"in e.data?o.resolve(s):o.reject(new Error(a)))},t}(r),e.exports=a},function(e,t){e.exports={stringifyFunctions:function(e,t){var n,r;if(null==t&&(t=[]),"function"==typeof e)return e.toString().replace(/\s\s+/g," ");if("object"==typeof e){if(t.indexOf(e)>=0);else{t.push(e);for(n in e)r=e[n],e[n]=this.stringifyFunctions(r,t)}return e}return e}}},function(e,t){e.exports="var factory,\n  slice = [].slice;\n\nfactory = function() {\n  var Connection;\n  Connection = {};\n  Connection.API = (function() {\n    API.prototype.CONNECTION_TIMEOUT = 3000;\n\n    API.prototype.REQUEST_TIMEOUT = 3000;\n\n    function API(name1, migrations1) {\n      this.name = name1;\n      this.migrations = migrations1;\n      this.database = null;\n      this.queue = {};\n      this.logging = new Connection.Logging;\n    }\n\n    API.prototype.parseMigrations = function(migrations) {\n      var keys;\n      keys = Object.keys(migrations).sort();\n      return keys.map((function(_this) {\n        return function(k) {\n          var title, titleMatches, version;\n          version = parseInt(k);\n          titleMatches = k.match(/_(.+)/);\n          title = titleMatches ? titleMatches[1].replace(/(\\w)([A-Z])/g, function($1, $2, $3) {\n            return $2 + \" \" + ($3.toLowerCase());\n          }) : '';\n          return {\n            version: version,\n            title: title,\n            migration: migrations[k],\n            key: k\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.deleteDatabase = function() {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          var request;\n          if (!_this.database) {\n            return resolve();\n          }\n          _this.close();\n          request = indexedDB.deleteDatabase(_this.database.name);\n          return request.onsuccess = function(e) {\n            return setTimeout((function() {\n              return resolve();\n            }), 0);\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.open = function() {\n      if (this.dbPromise) {\n        return this.dbPromise;\n      }\n      return this.dbPromise = new Promise((function(_this) {\n        return function(resolve, reject) {\n          var e, migrations, request;\n          if (!self.indexedDB) {\n            return reject('indexedDB isn’t supported');\n          }\n          migrations = _this.parseMigrations(_this.migrations);\n          try {\n            request = indexedDB.open(_this.name, migrations.length + 1);\n            if ((_this.CONNECTION_TIMEOUT != null) && _this.CONNECTION_TIMEOUT > -1) {\n              request.__timeout = setTimeout(function() {\n                request.__timedout = true;\n                return reject(new Error('Connection timed out'));\n              }, _this.CONNECTION_TIMEOUT);\n            }\n          } catch (error) {\n            e = error;\n            clearTimeout(request.__timeout);\n            return reject(e.message || e.name);\n          }\n          request.onupgradeneeded = function(e) {\n            var db, j, len, migration, migrationTransaction, results, transaction;\n            clearTimeout(request.__timeout);\n            if (request.__timedout) {\n              return;\n            }\n            db = e.target.result;\n            transaction = e.target.transaction;\n            migrationTransaction = new Connection.Migration(db, transaction);\n            migrationTransaction.createObjectStore('migrations', {\n              keyPath: 'version'\n            });\n            results = [];\n            for (j = 0, len = migrations.length; j < len; j++) {\n              migration = migrations[j];\n              if (typeof migration.migration === 'string') {\n                migration.migration = eval(\"__\" + migration.key + \" = \" + migration.migration);\n              }\n              (migration.migration.up || migration.migration).bind(migrationTransaction).call();\n              delete migration.migration;\n              results.push(transaction.objectStore('migrations').put(migration));\n            }\n            return results;\n          };\n          request.onsuccess = function(e) {\n            var db, objectStoreNames;\n            clearTimeout(request.__timeout);\n            if (request.__timedout) {\n              return;\n            }\n            db = e.target.result;\n            objectStoreNames = [].slice.call(db.objectStoreNames);\n            _this.createNamespaceForObjectStores(objectStoreNames);\n            db.onversionchange = function() {\n              return _this.close();\n            };\n            _this.database = db;\n            return resolve(objectStoreNames);\n          };\n          return request.onerror = function(e) {\n            return reject(request.error.message || request.error.name);\n          };\n        };\n      })(this));\n    };\n\n    API.prototype.close = function() {\n      return new Promise((function(_this) {\n        return function(resolve) {\n          if (_this.dbPromise) {\n            delete _this.dbPromise;\n          }\n          if (_this.database) {\n            _this.database.close();\n          }\n          return resolve();\n        };\n      })(this));\n    };\n\n    API.prototype.get = function(objectStoreName, key, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var promises;\n          if (Array.isArray(key)) {\n            promises = Promise.all(key.map(function(k) {\n              return _this.get(objectStoreName, k);\n            }));\n            return promises.then(resolve);\n          } else {\n            return _this.enqueue('read', objectStoreName, function(transaction) {\n              var request;\n              _this.logging.addRequest(transaction, 'get', objectStoreName, indexName, {\n                key: key\n              });\n              request = _this.createRequest({\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                indexName: indexName,\n                reject: reject\n              });\n              return request.get(key).onsuccess = function(e) {\n                var value;\n                clearTimeout(request.__timeout);\n                if (request.__timedout) {\n                  return;\n                }\n                value = e.target.result;\n                if (value === void 0) {\n                  value = null;\n                }\n                return resolve(value);\n              };\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.getFirst = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('read', objectStoreName, function(transaction) {\n            var request;\n            _this.logging.addRequest(transaction, 'getFirst', objectStoreName, indexName);\n            request = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              indexName: indexName,\n              reject: reject\n            });\n            return request.openCursor().onsuccess = function(e) {\n              var cursor, value;\n              clearTimeout(request.__timeout);\n              if (request.__timedout) {\n                return;\n              }\n              if (cursor = e.target.result) {\n                value = cursor.value;\n                if (!request.keyPath) {\n                  value._key = cursor.key;\n                }\n                return resolve(value);\n              } else {\n                return resolve(null);\n              }\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.getAll = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('read', objectStoreName, function(transaction) {\n            var request, result;\n            _this.logging.addRequest(transaction, 'getAll', objectStoreName, indexName);\n            result = [];\n            request = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              indexName: indexName,\n              reject: reject\n            });\n            return request.openCursor().onsuccess = function(e) {\n              var cursor, value;\n              clearTimeout(request.__timeout);\n              if (request.__timedout) {\n                return;\n              }\n              if (!(cursor = e.target.result)) {\n                return resolve(result);\n              }\n              value = cursor.value;\n              if (!request.keyPath) {\n                value._key = cursor.key;\n              }\n              result.push(value);\n              return cursor[\"continue\"]();\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.count = function(objectStoreName, indexName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('read', objectStoreName, function(transaction) {\n            var request;\n            _this.logging.addRequest(transaction, 'count', objectStoreName, indexName);\n            request = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              indexName: indexName,\n              reject: reject\n            });\n            return request.count().onsuccess = function(e) {\n              var value;\n              clearTimeout(request.__timeout);\n              if (request.__timedout) {\n                return;\n              }\n              value = e.target.result;\n              if (!value) {\n                value = 0;\n              }\n              return resolve(value);\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.add = function(objectStoreName, key, data) {\n      var ref;\n      if (data === void 0) {\n        ref = [null, key], key = ref[0], data = ref[1];\n      }\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var promises;\n          if (!key && Array.isArray(data)) {\n            promises = Promise.all(data.map(function(d) {\n              return _this.add(objectStoreName, d);\n            }));\n            return promises.then(resolve);\n          } else if (key && Array.isArray(key) && Array.isArray(data)) {\n            promises = Promise.all(key.map(function(key, i) {\n              return _this.add(objectStoreName, key, data[i]);\n            }));\n            return promises.then(resolve);\n          } else {\n            return _this.enqueue('write', objectStoreName, function(transaction) {\n              var args, request;\n              _this.logging.addRequest(transaction, 'add', objectStoreName, null, {\n                key: key,\n                data: data\n              });\n              args = key ? [data, key] : [data];\n              request = _this.createRequest({\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              });\n              return request.put.apply(request, args).onsuccess = function(e) {\n                clearTimeout(request.__timeout);\n                if (request.__timedout) {\n                  return;\n                }\n                data._key = e.target.result;\n                return resolve(data);\n              };\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.update = function(objectStoreName, key, value) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('write', objectStoreName, function(transaction) {\n            var getRequest;\n            _this.logging.addRequest(transaction, 'update', objectStoreName, null, {\n              key: key,\n              data: value\n            });\n            getRequest = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              reject: reject\n            });\n            return getRequest.get(key).onsuccess = function(e) {\n              var args, data, deepUpdate, hasKeyPath, keyPath, putRequest;\n              clearTimeout(getRequest.__timeout);\n              if (getRequest.__timedout) {\n                return;\n              }\n              keyPath = e.target.source.keyPath;\n              hasKeyPath = !!keyPath;\n              data = e.target.result;\n              if (data === void 0) {\n                data = value;\n                if (hasKeyPath) {\n                  data[keyPath] = key;\n                }\n              } else {\n                deepUpdate = function(o, root) {\n                  var k, results, v;\n                  results = [];\n                  for (k in o) {\n                    v = o[k];\n                    if (typeof v === 'object') {\n                      deepUpdate(v, root[k]);\n                      continue;\n                    }\n                    results.push(root[k] = v);\n                  }\n                  return results;\n                };\n                deepUpdate(value, data);\n              }\n              args = hasKeyPath ? [data] : [data, key];\n              putRequest = _this.createRequest({\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              });\n              return putRequest.put.apply(putRequest, args).onsuccess = function() {\n                clearTimeout(putRequest.__timeout);\n                if (putRequest.__timedout) {\n                  return;\n                }\n                return resolve(data);\n              };\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.increment = function(objectStoreName, key, value, decrement) {\n      if (value == null) {\n        value = 1;\n      }\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('write', objectStoreName, function(transaction) {\n            var getRequest;\n            _this.logging.addRequest(transaction, (decrement ? 'decrement' : 'increment'), objectStoreName, null, {\n              key: key,\n              data: value\n            });\n            getRequest = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              reject: reject\n            });\n            return getRequest.get(key).onsuccess = function(e) {\n              var args, data, deepIncrement, hasKeyPath, keyPath, putRequest;\n              clearTimeout(getRequest.__timeout);\n              if (getRequest.__timedout) {\n                return;\n              }\n              keyPath = e.target.source.keyPath;\n              hasKeyPath = !!keyPath;\n              data = e.target.result;\n              if (hasKeyPath) {\n                deepIncrement = function(o, root) {\n                  var k, results, v;\n                  results = [];\n                  for (k in o) {\n                    v = o[k];\n                    if (typeof v === 'object') {\n                      deepIncrement(v, root[k]);\n                      continue;\n                    }\n                    root[k] || (root[k] = 0);\n                    results.push(root[k] += decrement ? -v : v);\n                  }\n                  return results;\n                };\n                deepIncrement(value, data);\n              } else {\n                data || (data = 0);\n                data += decrement ? -value : value;\n              }\n              args = hasKeyPath ? [data] : [data, key];\n              putRequest = _this.createRequest({\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              });\n              return putRequest.put.apply(putRequest, args).onsuccess = function() {\n                clearTimeout(putRequest.__timeout);\n                if (putRequest.__timedout) {\n                  return;\n                }\n                return resolve(data);\n              };\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.decrement = function(objectStoreName, key, value) {\n      return this.increment(objectStoreName, key, value, true);\n    };\n\n    API.prototype[\"delete\"] = function(objectStoreName, key) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var promises;\n          if (Array.isArray(key)) {\n            promises = Promise.all(key.map(function(k) {\n              return _this[\"delete\"](objectStoreName, k);\n            }));\n            return promises.then(resolve);\n          } else {\n            return _this.enqueue('write', objectStoreName, function(transaction) {\n              var request;\n              _this.logging.addRequest(transaction, 'delete', objectStoreName, null, {\n                key: key\n              });\n              request = _this.createRequest({\n                transaction: transaction,\n                objectStoreName: objectStoreName,\n                reject: reject\n              });\n              return request[\"delete\"](key).onsuccess = function(e) {\n                clearTimeout(request.__timeout);\n                if (request.__timedout) {\n                  return;\n                }\n                return resolve(key);\n              };\n            });\n          }\n        };\n      })(this));\n    };\n\n    API.prototype.deleteWhere = function(objectStoreName, predicates, indexName) {\n      predicates.remove = true;\n      return this.where(objectStoreName, predicates, indexName);\n    };\n\n    API.prototype.clear = function(objectStoreName) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue('write', objectStoreName, function(transaction) {\n            var request;\n            _this.logging.addRequest(transaction, 'clear', objectStoreName);\n            request = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              reject: reject\n            });\n            return request.clear().onsuccess = function() {\n              clearTimeout(request.__timeout);\n              if (request.__timedout) {\n                return;\n              }\n              return resolve();\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.clearAll = function() {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var objectStoreNames, promises;\n          objectStoreNames = slice.call(_this.database.objectStoreNames);\n          objectStoreNames = objectStoreNames.filter(function(objectStoreName) {\n            return objectStoreName !== 'migrations';\n          });\n          promises = Promise.all(objectStoreNames.map(function(objectStoreName) {\n            return _this.clear(objectStoreName);\n          }));\n          promises.then(resolve);\n          return promises[\"catch\"](reject);\n        };\n      })(this));\n    };\n\n    API.prototype.reset = function(objectStoreName, key, data) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var clearPromise;\n          clearPromise = _this.clear(objectStoreName);\n          clearPromise[\"catch\"](reject);\n          return clearPromise.then(function() {\n            var addPromise;\n            addPromise = _this.add(objectStoreName, key, data);\n            addPromise[\"catch\"](reject);\n            return addPromise.then(resolve);\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.index = function(objectStoreName, indexName) {\n      return this.createNamespaceForIndex(indexName, objectStoreName);\n    };\n\n    API.prototype.where = function(objectStoreName, predicates, indexName) {\n      var readWrite;\n      readWrite = predicates.remove ? 'write' : 'read';\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.enqueue(readWrite, objectStoreName, function(transaction) {\n            var bound, bounds, contains, count, eq, eqIsArray, exact, except, gt, gteq, hasValues, isEquivalent, isInclusive, isLowerBound, k, knownUniques, limit, lower, lt, lteq, offset, only, order, range, ref, remove, request, result, uniq, uniques, upper, v;\n            _this.logging.addRequest(transaction, 'where', objectStoreName, indexName, {\n              data: predicates\n            });\n            lt = predicates.lt, lteq = predicates.lteq, gt = predicates.gt, gteq = predicates.gteq, eq = predicates.eq, limit = predicates.limit, offset = predicates.offset, only = predicates.only, contains = predicates.contains, except = predicates.except, uniq = predicates.uniq, order = predicates.order, remove = predicates.remove;\n            uniques = Array.isArray(uniq) ? uniq : uniq ? [uniq] : [];\n            order = order === 'desc' ? 'prev' : 'next';\n            bounds = {};\n            ref = {\n              lt: lt,\n              lteq: lteq,\n              gt: gt,\n              gteq: gteq,\n              eq: eq\n            };\n            for (k in ref) {\n              v = ref[k];\n              if (v === void 0) {\n                continue;\n              }\n              isInclusive = k === 'gteq' || k === 'lteq';\n              isEquivalent = k === 'eq';\n              isLowerBound = k === 'gt' || k === 'gteq';\n              bound = isEquivalent ? 'exact' : isLowerBound ? 'lower' : 'upper';\n              bounds[bound] = {\n                value: v,\n                open: !isInclusive\n              };\n            }\n            range = null;\n            eqIsArray = false;\n            lower = bounds.lower, upper = bounds.upper, exact = bounds.exact;\n            if (exact) {\n              if (eqIsArray = Array.isArray(eq)) {\n                eq.sort();\n                lower = {\n                  value: eq[0],\n                  open: false\n                };\n                upper = {\n                  value: eq[eq.length - 1],\n                  open: false\n                };\n                range = IDBKeyRange.bound(lower.value, upper.value, lower.open, upper.open);\n              } else {\n                range = IDBKeyRange.only(exact.value);\n              }\n            } else if (lower && upper) {\n              range = IDBKeyRange.bound(lower.value, upper.value, lower.open, upper.open);\n            } else if (lower) {\n              range = IDBKeyRange.lowerBound(lower.value, lower.open);\n            } else if (upper) {\n              range = IDBKeyRange.upperBound(upper.value, upper.open);\n            }\n            result = [];\n            count = 0;\n            knownUniques = {};\n            hasValues = function(object, k, v) {\n              if (!Array.isArray(v)) {\n                v = [v];\n              }\n              return v.indexOf(object[k]) !== -1;\n            };\n            request = _this.createRequest({\n              transaction: transaction,\n              objectStoreName: objectStoreName,\n              indexName: indexName,\n              reject: reject\n            });\n            request = range ? request.openCursor(range, order) : request.openCursor();\n            return request.onsuccess = function(e) {\n              var a, cursor, j, keyPath, knownValues, len, value;\n              clearTimeout(request.__timeout);\n              if (request.__timedout) {\n                return;\n              }\n              if (!(cursor = e.target.result)) {\n                return resolve(result);\n              }\n              value = cursor.value;\n              if (eqIsArray) {\n                keyPath = e.target.source.keyPath;\n                only || (only = {});\n                only[keyPath] = eq;\n              }\n              for (k in only) {\n                v = only[k];\n                if (!hasValues(value, k, v)) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (k in contains) {\n                v = contains[k];\n                if (!Array.isArray(v)) {\n                  v = [v];\n                }\n                a = value[k];\n                if (!Array.isArray(a)) {\n                  a = [a];\n                }\n                if (!_this.intersect(a, v).length) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (k in except) {\n                v = except[k];\n                if (hasValues(value, k, v)) {\n                  return cursor[\"continue\"]();\n                }\n              }\n              for (j = 0, len = uniques.length; j < len; j++) {\n                k = uniques[j];\n                knownValues = knownUniques[k] || (knownUniques[k] = []);\n                if (knownValues.indexOf(value[k]) !== -1) {\n                  return cursor[\"continue\"]();\n                }\n                knownUniques[k].push(value[k]);\n              }\n              count++;\n              if (offset && count <= offset) {\n                return cursor[\"continue\"]();\n              }\n              result.push(value);\n              if (remove) {\n                cursor[\"delete\"]();\n              }\n              if (limit) {\n                if (typeof limit === 'string') {\n                  limit = eval(\"__limit = \" + limit);\n                }\n                if (typeof limit === 'function' && limit(result)) {\n                  return resolve(result);\n                } else if (limit === result.length) {\n                  return resolve(result);\n                }\n              }\n              return cursor[\"continue\"]();\n            };\n          });\n        };\n      })(this));\n    };\n\n    API.prototype.getMethodsForObjectStore = function() {\n      return this._getMethodsForObjectStore || (this._getMethodsForObjectStore = ['get', 'getFirst', 'getAll', 'count', 'add', 'update', 'increment', 'decrement', 'delete', 'deleteWhere', 'clear', 'reset', 'index', 'where']);\n    };\n\n    API.prototype.getMethodsForIndex = function() {\n      return this._getMethodsForIndex || (this._getMethodsForIndex = ['get', 'getFirst', 'getAll', 'count', 'where', 'deleteWhere']);\n    };\n\n    API.prototype.createNamespaceForObjectStores = function(objectStoreNames, context) {\n      var j, len, objectStoreName, results;\n      if (objectStoreNames == null) {\n        objectStoreNames = [];\n      }\n      if (context == null) {\n        context = this;\n      }\n      results = [];\n      for (j = 0, len = objectStoreNames.length; j < len; j++) {\n        objectStoreName = objectStoreNames[j];\n        if (objectStoreName === 'migrations') {\n          continue;\n        }\n        results.push(this.createNamespaceForObjectStore(objectStoreName, context));\n      }\n      return results;\n    };\n\n    API.prototype.createNamespaceForObjectStore = function(objectStoreName, context) {\n      var namespace;\n      if (context == null) {\n        context = this;\n      }\n      namespace = context[objectStoreName] = {};\n      this.getMethodsForObjectStore().forEach((function(_this) {\n        return function(method) {\n          return namespace[method] = function() {\n            return context[method].apply(context, [objectStoreName].concat(slice.call(arguments)));\n          };\n        };\n      })(this));\n      return namespace;\n    };\n\n    API.prototype.createNamespaceForIndex = function(indexName, objectStoreName, context) {\n      var namespace;\n      if (context == null) {\n        context = this;\n      }\n      namespace = {};\n      this.getMethodsForIndex().forEach((function(_this) {\n        return function(method) {\n          return namespace[method] = function() {\n            return context[method].apply(context, [objectStoreName].concat(slice.call(arguments), [indexName]));\n          };\n        };\n      })(this));\n      return namespace;\n    };\n\n    API.prototype.createRequest = function(arg) {\n      var indexName, objectStore, objectStoreName, reject, request, transaction;\n      transaction = arg.transaction, objectStoreName = arg.objectStoreName, indexName = arg.indexName, reject = arg.reject;\n      objectStore = transaction.objectStore(objectStoreName);\n      request = indexName ? objectStore.index(indexName) : objectStore;\n      if (reject && (this.REQUEST_TIMEOUT != null) && this.REQUEST_TIMEOUT > -1) {\n        request.__timeout = setTimeout(function() {\n          request.__timedout = true;\n          return reject(new Error('Request timed out'));\n        }, this.REQUEST_TIMEOUT);\n      }\n      return request;\n    };\n\n    API.prototype.createTransaction = function(mode, objectStoreName, callback) {\n      return this.open().then((function(_this) {\n        return function() {\n          var transaction;\n          transaction = _this.database.transaction([objectStoreName], mode);\n          return callback(transaction);\n        };\n      })(this))[\"catch\"]((function(_this) {\n        return function(err) {\n          throw err;\n        };\n      })(this));\n    };\n\n    API.prototype.intersect = function(a, b) {\n      var ai, bi, result;\n      ai = 0;\n      bi = 0;\n      result = [];\n      while (ai < a.length && bi < b.length) {\n        if (a[ai] < b[bi]) {\n          ai++;\n        } else if (a[ai] > b[bi]) {\n          bi++;\n        } else {\n          result.push(a[ai]);\n          ai++;\n          bi++;\n        }\n      }\n      return result;\n    };\n\n    API.prototype.enqueue = function(readwrite, objectStoreName, callback) {\n      var base, request;\n      (base = this.queue)[objectStoreName] || (base[objectStoreName] = []);\n      request = {\n        readwrite: readwrite,\n        callback: callback\n      };\n      if (!this.queue[objectStoreName].length) {\n        this.scheduleTransaction(objectStoreName);\n      }\n      return this.queue[objectStoreName].push(request);\n    };\n\n    API.prototype.scheduleTransaction = function(objectStoreName) {\n      return setTimeout((function(_this) {\n        return function() {\n          var mode, modes, needsWriteMode, requests;\n          requests = _this.queue[objectStoreName].splice(0);\n          modes = requests.map(function(r) {\n            return r.readwrite;\n          });\n          needsWriteMode = modes.some(function(m) {\n            return m === 'write';\n          });\n          mode = needsWriteMode ? 'readwrite' : 'readonly';\n          return _this.createTransaction(mode, objectStoreName, function(transaction) {\n            var j, len, request, results;\n            _this.logging.addTransaction(transaction, objectStoreName);\n            results = [];\n            for (j = 0, len = requests.length; j < len; j++) {\n              request = requests[j];\n              results.push(request.callback(transaction));\n            }\n            return results;\n          });\n        };\n      })(this), 0);\n    };\n\n    return API;\n\n  })();\n  Connection.Migration = (function() {\n    function Migration(db1, transaction1) {\n      this.db = db1;\n      this.transaction = transaction1;\n    }\n\n    Migration.prototype.createObjectStore = function(name, options) {\n      if (this.db.objectStoreNames.contains(name)) {\n        return;\n      }\n      return this.db.createObjectStore(name, options);\n    };\n\n    Migration.prototype.deleteObjectStore = function(name) {\n      if (!this.db.objectStoreNames.contains(name)) {\n        return;\n      }\n      return this.db.deleteObjectStore(name);\n    };\n\n    Migration.prototype.createIndex = function(objectStoreName, indexName, keyPath, options) {\n      var objectStore;\n      objectStore = this.transaction.objectStore(objectStoreName);\n      if (objectStore && objectStore.indexNames.contains(indexName)) {\n        return;\n      }\n      return objectStore.createIndex(indexName, keyPath, options);\n    };\n\n    Migration.prototype.deleteIndex = function(objectStoreName, indexName) {\n      var objectStore;\n      objectStore = this.transaction.objectStore(objectStoreName);\n      if (!(objectStore && objectStore.indexNames.contains(indexName))) {\n        return;\n      }\n      return objectStore.deleteIndex(indexName);\n    };\n\n    return Migration;\n\n  })();\n  Connection.Logging = (function() {\n    function Logging() {\n      this.queues = [];\n    }\n\n    Logging.prototype.addTransaction = function(transaction, objectStoreNames) {\n      var callback;\n      if (!this.handleLog) {\n        return;\n      }\n      this.queues.push({\n        transaction: transaction,\n        objectStoreNames: objectStoreNames,\n        requests: [],\n        start: Date.now()\n      });\n      callback = (function(_this) {\n        return function(e) {\n          return _this.logTransaction(e.target);\n        };\n      })(this);\n      transaction.onabort = callback;\n      transaction.onerror = callback;\n      return transaction.oncomplete = callback;\n    };\n\n    Logging.prototype.addRequest = function(transaction, method, objectStoreName, indexName, data) {\n      var queue;\n      if (!this.handleLog) {\n        return;\n      }\n      queue = this.queues.filter(function(q) {\n        return q.transaction === transaction;\n      })[0];\n      if (!queue) {\n        return;\n      }\n      return queue.requests.push({\n        method: method,\n        objectStoreName: objectStoreName,\n        indexName: indexName,\n        data: data\n      });\n    };\n\n    Logging.prototype.logTransaction = function(transaction) {\n      var data, end, indexName, j, key, len, logs, method, mode, objectStoreName, queue, ref, ref1, request, requestsLenght, time;\n      if (!this.handleLog) {\n        return;\n      }\n      queue = this.queues.filter(function(q) {\n        return q.transaction === transaction;\n      })[0];\n      if (!queue) {\n        return;\n      }\n      mode = queue.transaction.mode === 'readwrite' ? 'write' : 'read ';\n      requestsLenght = queue.requests.length;\n      end = Date.now();\n      time = end - queue.start;\n      this.handleLog({\n        type: 'transaction.start',\n        data: \"Ndex: \" + mode + \" \" + queue.objectStoreNames + \" \" + time + \"ms (\" + requestsLenght + \" request\" + (requestsLenght > 1 ? 's' : '') + \")\"\n      });\n      ref = queue.requests;\n      for (j = 0, len = ref.length; j < len; j++) {\n        request = ref[j];\n        method = request.method, objectStoreName = request.objectStoreName, indexName = request.indexName, data = request.data;\n        if (data) {\n          ref1 = data, key = ref1.key, data = ref1.data;\n        }\n        logs = [];\n        switch (method) {\n          case 'get':\n            logs = ['GET', key, 'FROM', objectStoreName];\n            break;\n          case 'getFirst':\n            logs = ['GET FIRST', key, 'FROM', objectStoreName];\n            break;\n          case 'getAll':\n            logs = ['GET ALL', 'FROM', objectStoreName];\n            break;\n          case 'count':\n            logs = ['COUNT', 'FROM', objectStoreName];\n            break;\n          case 'add':\n            logs = ['ADD', JSON.stringify(data), 'TO', objectStoreName];\n            if (key) {\n              logs = logs.concat(['WITH KEY', key]);\n            }\n            break;\n          case 'update':\n            logs = ['UPDATE', key, 'FROM', objectStoreName, 'SET', JSON.stringify(data)];\n            break;\n          case 'increment':\n            if (typeof data === 'object') {\n              data = JSON.stringify(data);\n            }\n            logs = ['INCREMENT', data, 'TO KEY', key, 'FROM', objectStoreName];\n            break;\n          case 'decrement':\n            if (typeof data === 'object') {\n              data = JSON.stringify(data);\n            }\n            logs = ['DECREMENT', data, 'TO KEY', key, 'FROM', objectStoreName];\n            break;\n          case 'delete':\n            logs = ['DELETE', key, 'FROM', objectStoreName];\n            break;\n          case 'clear':\n            logs = ['CLEAR', objectStoreName];\n            break;\n          case 'where':\n            if (typeof data.limit === 'function') {\n              data.limit = '[FUNCTION]';\n            }\n            logs = ['WHERE', JSON.stringify(data), 'FROM', objectStoreName];\n        }\n        if (indexName) {\n          logs = logs.concat(['INDEX', indexName]);\n        }\n        this.handleLog({\n          type: 'request',\n          data: logs.join(' ')\n        });\n      }\n      return this.handleLog({\n        type: 'transaction.end'\n      });\n    };\n\n    return Logging;\n\n  })();\n  return Connection.API;\n};\n\nif (typeof exports !== 'undefined') {\n  module.exports = factory();\n} else {\n  this.Connection = factory();\n}\n";
},function(e,t){e.exports="var handleLogging, init;\n\ninit = function(arg) {\n  var migrations, name;\n  name = arg.name, migrations = arg.migrations;\n  return this.connection = new Connection(name, migrations);\n};\n\nhandleLogging = function() {\n  return this.connection.logging.handleLog = function(args) {\n    return postMessage({\n      method: 'handleLog',\n      args: args\n    });\n  };\n};\n\nself.onmessage = (function(_this) {\n  return function(e) {\n    var data;\n    data = e.data;\n    if (!Array.isArray(data)) {\n      data = [data];\n    }\n    return data.forEach(function(datum) {\n      var args, id, method;\n      id = datum.id, method = datum.method, args = datum.args;\n      if (typeof _this[method] === 'function') {\n        return _this[method](args);\n      }\n      return _this.connection[method].apply(_this.connection, args).then(function(data) {\n        return postMessage({\n          id: id,\n          resolve: data\n        });\n      })[\"catch\"](function(data) {\n        return postMessage({\n          id: id,\n          reject: data\n        });\n      });\n    });\n  };\n})(this);\n"}])});